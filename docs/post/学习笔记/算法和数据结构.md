# 算法和数据结构

- 完全二叉树的叶子节点  $\lfloor\frac{n+1}{2}\rfloor$

- 二叉搜索树

  时间复杂度：$O(logn),O(n)$

  查找和添加元素通过比较大小来确定位置，删除元素需要借助前驱或者后继节点，交换之后删除。

  可能退化成链表。

- AVL树

  平衡二叉树，平衡的定义是左右子树的高度差不大于1。

  通过旋转操作来保持平衡。每调整最多$logn$次。

- 红黑树

  类似4阶B树，节点只有两种颜色，红色和黑色。红黑树不是绝对的平衡，牺牲平衡换取速度。

  节点是红色或黑色。

  根节点是黑色。

  叶子节点是黑色(NULL)

  红色节点的子节点是黑色

  - 红色节点的父节点是黑色
  - 根节点到叶子节点的所有路径上不能有2个连续的红色节点。

  任意节点到叶子节点的所有路径上包含相同数量的黑色节点。

  

  删除元素的时候，AVL可能要对所有的父节点的进行调整；红黑树最多三次旋转。

  AVL适于搜索多的操作，红黑树比较均衡。



## 常用的排序算法

### 归并排序

将大的数组分成两个，然后对两个数组进行合并。

- 时间复杂度$O(nlog_2n)$
- 空间复杂度$O(n)$
- 稳定
- 非原地排序

```c
void merge(int *arr, int l, int mid, int r, int *tmp) {
	int i = l; 		// 左数组
	int j = mid+1;	// 右数组
	int t = l;		// 合并的数组
	while (i <= mid && j <= r) {
		if (arr[i] < arr[j]) {
			tmp[t++] = arr[i++];
		}else {
			tmp[t++] = arr[j++];
		}
	}
	while (i <= mid) tmp[t++] = arr[i++];
	while (j <= r) tmp[t++] = arr[j++];
	for (int i = l; i <= r; ++i) {
		arr[i] = tmp[i];
	}
}

// 递归版本
void mergeSort(int *arr, int l, int r, int *tmp) {
	if (l == r) return;
	int mid = (l + r) >> 1;
	mergeSort(arr, l, mid, tmp);
	mergeSort(arr, mid+1, r, tmp);
	merge(arr, l, mid, r, tmp);
}

// 非递归版本
void mergeSort(int *arr, int len, int *tmp) {
	for (int i = 1; i < len; i += i) {
		for (int j = 0; j <= len; j += i*2) {
			int l = j;
			int mid = min(j+i-1, len-1);
			int r = min(j+i*2-1, len-1);
			merge(arr, l, mid, r, tmp);
		}
	}
}
```



### 快速排序

每次选择一个基准数x，从左到右找到第一个大于x的数，从右向左找到第一个大于x的数，交换两个数字。

这样每次可以确定一个x的位置，同时数字的左边都不大于x，右边的数不小于x。然后递归左右。

可能会退化为冒泡排序。

- 时间复杂度$O(nlog_2n)、O(n^2)$
- 空间复杂度$O(log_2n)、 O(n)$
- 不稳定
- 原地排序

```c
void quickSort(int* arr, int l, int r) {
	if (l >= r) return;
	int x = arr[l];
	int i = l + 1;
	int j = r;
	while (i <= j) {
		// 右到左找到一个小于x的数
		while (i <= j && arr[j] >= x) --j;
		// 左到右找到一个大于x的数
		while (i <= j && arr[i] <= x) ++i;
		// 交换位置
		if (i <= j) swap(arr[i], arr[j]);
	}
	// 确定x的位置
	swap(arr[l], arr[j]);
	quickSort(arr, l, j - 1);
	quickSort(arr, j + 1, r);
}
```

### 堆排序

将数组对应建一个完全二叉树，节点编号从0开始，从最后一个非叶子节点（len / 2 - 1），开始调整。

升序建立大顶堆，降序建小顶堆。

将堆顶和最后一个元素交换，这样就确定一个最大/小值，然后调整堆顶元素，重复操作。

- 时间复杂度$O(nlog_2n)$
- 空间复杂度$O(1))$
- 不稳定
- 原地排序

```c
void adjustHeap(int *arr, int i, int len) {
	int x = arr[i];
	// 从左孩子开始调整
	for (int k = i*2+1; k < len; k = k*2+1) {
		// k指向最大的孩子
		if (k+1 < len && arr[k] < arr[k+1]) k++;
		if (arr[k] > x) {
			arr[i] = arr[k];
			i = k;
		}else break;
	}
	arr[i] = x;
}

void heapSort(int *arr, int len) {
	// 构造大顶堆
	// 从第一个非叶子节点开始
	for (int i = len/2 - 1; i >= 0; --i) { 
		adjustHeap(arr, i, len);
	}
	// 堆顶元素交换到最后
	for (int i = len-1; i >= 0; --i) {
		swap(arr[0], arr[i]);
		adjustHeap(arr, 0, i);
	}
}
```



## STL底层数据结构

- vector

  动态数组，在堆上分配空间，空间不够用的，以原大小的两倍新分配一个内存空间，最好将结构体或者类的指针放到vector中，防止移动的构造和析构。

  适合随机访问，不适合大量的插入和删除。

  n次push_back()的复杂度是$O(1)$，需要$logn$次扩容，每次拷贝$2^i$，均摊每次push_back的复杂度是$O(1)$

- list

  双向链表，不支持随机访问，插入删除元素，对应分配释放堆空间。

- deque

  双向开口的连续空间，可以在两端插入删除元素，支持随机访问。

- stack、queue

  先进后出、先进先出，适配器是对deque容器的再封装。

- priority_queue

  以vector为底层容器，加上heap处理规则

- set、multiset

  底层红黑树实现，按照键值排序，set没有重复元素，multiset可以有重复元素。

- map、unordered_map

  map底层红黑树，按照key排序，自定义类型数据需要重载 <

  unordered_map底层哈希表，自定义数据类型，需要重载 =



## Hash

Hash也称为散列、哈希。原理是把任意长度的输入，通过Hash计算得到一个固定长度的输出。

hash在数据结构中的含义和密码学中的含义并不相同，所以在这两种不同的领域里，算法的设计侧重点也不同。在密码学中，hash算法主要是用于消息摘要和签名。在数据结构中，hash主要是用于查询，侧重点在哈希算法的执行速度和冲突的解决。



### Hash的特点

- 不可逆性：不能从hash的值反向推到出原始数据。
- 均匀性：hash函数映射的值要保持均匀。
- 确定性：不同数据的hash值是不相同的。
- 混淆行：输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。
- 高效性：hash算法的执行效率要高效。



### Hash碰撞

Hash碰撞时不可避免的，解决碰撞的方法一般有两种：

- 开放地址法

  当发生冲突时，寻找一个空地址存放元素。

  - 线性探测法
  - 二次探测
  - 双重散列

  无论那种方法，当剩余空间很少时，冲突的发生的频率增加。需要设置一个装载因子来反映当前的冲突情况。$装载因子=\frac{输入的元素个数}{散列表的长度}$，如果超过了装载因子，可以对散列表进行扩充，重新进行hash。

- 链地址法

  使用链表保存数据，当存在冲突时，放到链表的后面。



### Hash的应用

- 信息加密，在服务端保存用户的密码的hash值，这样可以有效的避免密码的泄漏问题。但是如果所有的hash值被枚举出来了，也是不安全的。[CMD5 MD5密文查询](https://www.cmd5.com/)
- 数据校验，对数据生成hash值，判断是否被篡改。
- 版权校验，第一个用户上传的资源计算hash，后面如果出现相同的hash值就属于侵权，但是文件如果稍作改变就可能得到一个不同的hash值。（视频删除一帧，图像改变一个像素）。
- 大文件分块校验。大文件分开传输，为了保存文件时发布者自己传输的，可以对每个小文件做hash计算，如果小文件较多，可以把所有分块的hash值组合成一个大的字符串，对于这个字符串再做一次Hash运算，得到最终的hash。