基础知识

## 用户空间和内核空间

操作系统的核心是内核, 独立于普通的应用程序, 可以访问受保护的内存空间, 拥有访问底层硬件设备的所有权限. 为了保证用户进程不能直接操作内核, 保证内核安全, 操作系统将虚拟空间分为两部分, 内核空间和用户空间.
其中最高的1G字节(虚拟地址: 0xC0000000 到 0xFFFFFFFF)为内核区域, 低位的3G(虚拟地址: 0x00000000 到 0xBFFFFFFF)为用户空间.

## 进程切换

内核挂起CPU上运行的进程, 恢复以前挂起的某个进程的执行.
从一个进程的运行到另一个进程的运行, 经历以下变化

1. 保存处理机上下文, 包括程序计数器和其他寄存器
2. 更新PCB信息
3. 把进程的PCB移入相应的队列, 就绪 阻塞等队列
4. 选择另一个进程执行, 更新PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文

## IO

同步: 调用一个功能, 功能没有结束, 一直等待结果
异步: 调用一个功能, 不需要知道功能结果, 有结果通过回调通知
阻塞: 调用函数, 杉树没有接受完数据或没有结果之前不返回
非阻塞: 调用函数, 函数立即返回, 通过select通知调用者
同步IO和异步IO的区别: 数据拷贝时进程是否阻塞
阻塞IO和非阻塞IO的区别: 应用程序的调用是否立即返回





## 链接的追踪

![](img/链接的追踪.jpg)



## 交换空间

![](img/swap.jpg)

## 常用命令

查找结构体所在文件

```bash
grep -r "task_struct {" /usr/include
```



查看资源限制

```bash
ulimit -a
```

查看信号

```bash
kil -l
```





## 进程间通信 IPC

## 文件类型

| 符号 | 文件类型 |
| ---- | -------- |
| -    | 文件     |
| d    | 目录     |
| l    | 符号链接 |
| s    | 套接字   |
| b    | 块设备   |
| c    | 字符设备 |
| p    | 管道     |

前三种占磁盘存储空间，后四种是伪文件，不占用磁盘空间。


## 线程

LWP: light weight process 轻量级的进程, 本质是进程
进程: 独立地址空间, 拥有PCB
线程: 共享地址空间, 拥有PCB
Linux下， 线程是最小的执行单位，进程是最小的资源分配单位可以看作只有一个线程的进程

线程提高程序占有cpu的时间

线程共享的资源：
- 文件描述符表
- 每种信号的处理方式
- 当前工作目录
- 用户ID和组ID
- 内存地址空间(.text/.data/.bss/heap/共享库)

线程非共享资源
- 线程ID
- 处理器现场和栈指针(内核栈)
- 独立的栈空间(用户空间栈)
- errno变量
- 信号屏蔽字
- 调度优先级

优点:
- 提高程序并发性
- 开销小
- 数据通信、共享数据方便

缺点:
- 使用库函数不稳定
- 调试困难, 编写困难, gdb不支持
- 对信号支持不好

### 创建线程

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void *thrd_func() {
	printf("In thread: pthread id = %lu, pid = %d\n", pthread_self(), getpid());
	return NULL;
}

int main() {

	pthread_t tid;
	int ret;

	printf("In main1: pthread id = %lu, pid = %d\n", pthread_self(), getpid());

	ret = pthread_create(&tid, NULL, thrd_func, NULL);
	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		printf("pthread_create error\n");
		exit(1);
	}
	// sleep(1);
	printf("In main2: pthread id = %lu, pid = %d\n", pthread_self(), getpid());
	// return 0;
	pthread_exit(NULL);
}
```

### 循环创建多个线程

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void *thrd_func(void *arg) {
	int i = (int)arg;
	sleep(i);
	printf("%dtd In thread: pthread id = %lu, pid = %d\n", i+1, pthread_self(), getpid());
	return NULL;
}

int main() {

	pthread_t tid;
	int ret, i;

	for (i = 0; i < 5; ++i) {
		ret = pthread_create(&tid, NULL, thrd_func, (void *)i);
		if (ret != 0) {
			fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
			printf("pthread_create error\n");
			exit(1);
		}
	}
	sleep(i);
	return 0;
}

```

### 回收线程

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>

typedef struct {
	int a;
	int b;
}exit_t;

void *tfn(void *arg) {
	exit_t *ret = (exit_t *) arg;
	ret->a = 100;
	ret->b = 200;
	printf("thread: %p\n", ret);
	pthread_exit((void*) ret);
}

int main() {
  	// int pthread_join(pthread_t thread, void **retval);
	pthread_t tid;
	exit_t *retval = malloc(sizeof(exit_t));
	int ret;

	ret = pthread_create(&tid, NULL, tfn, (void *)retval);
	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		exit(1);
	}
	pthread_join(tid, (void **)&retval);
	printf("main: %p\n", retval);
	printf("a = %d, b = %d\n", retval->a, retval->b);
	free(retval);

	return 0;
}
```

### 线程分离

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void *tfn(void *arg) {
	printf("pthread id : %lu\n", pthread_self());
	pthread_exit(NULL);
}

int main() {

	// int pthread_detach(pthread_t thread);
	// 线程主动和主控线程断开关系，线程结束后退出状态不由其他线程获取，直接释放，无系统残留资源
	pthread_t tid;
	int ret, err;
	void *tret;
	
	ret = pthread_create(&tid, NULL, tfn, NULL);
	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		exit(1);
	}
	pthread_detach(tid);
	while(1) {
		err = pthread_join(tid, (void **)&tret);
		printf("pthread err: %d\n", err);
		if (err != 0) {
			fprintf(stderr, "pthread_join error: %s\n", strerror(err));
		}else {
			fprintf(stderr, "thread exit code: %d\n", (int)tret);
		}
		sleep(1);
	}

	return 0;
}

```

### 取消线程
pthread_cancel, 需要到达一个检查点(取消点, 系统调用)，才能取消线程，可以手动加入取消点，pthread_testcancel()
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void sys_err(char *s, int err) {
	fprintf(stderr, "%s error: %s\n", s, strerror(err));
	exit(1);
}

void *tfn1(void *arg) {
	printf("thread1 is running!\n");
	pthread_exit((void*)111);
}


void *tfn2(void *arg) {
	while (1) {
		printf("thread2 is running!\n");
		sleep(1);
	}
	pthread_exit((void*)222);
}

int main() {
	pthread_t tid;
	int ret;
	void *retval;

	ret = pthread_create(&tid, NULL, tfn1, NULL);
	if (ret != 0) sys_err("pthread_create", ret);
	// pthread_detach(tid);
	ret = pthread_join(tid, (void**)&retval);
	if (ret != 0) sys_err("pthread_jon", ret);
	printf("thread1 retval: %d\n", (int)retval);

	ret = pthread_create(&tid, NULL, tfn2, NULL);
	if (ret != 0) sys_err("pthread_create", ret);
	
	sleep(3);

	ret = pthread_cancel(tid);
	if (ret != 0) sys_err("pthread_cancel", ret);
	ret = pthread_join(tid, (void**)&retval);
	if (ret != 0) sys_err("pthread_jon", ret);
	printf("thread2 retval: %d\n", (int)retval);

	return 0;
}
```
### 线程属性

```c
// 通过线程属性设置线程分离
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *tfn(void *arg){
	pthread_exit(NULL);
}

int main() {
	pthread_t tid;
	int ret;
	pthread_attr_t attr;
	void* retval;

	ret = pthread_attr_init(&attr);
	if (ret != 0) {
		if (ret != 0) {
			fprintf(stderr, "pthread_attr_init error: %s\n", strerror(ret));
			exit(1);
		}
	}

	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	ret = pthread_create(&tid, &attr, tfn, NULL);

	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		exit(1);
	}
	
	ret = pthread_join(tid, (void**)&retval);
	printf("pthread_join ret: %d\n", ret);

	pthread_attr_destory(&attr);
	return 0;
}
```
### 互斥量mutex
访问共享资源前加锁，访问结束后立即解锁，锁的"粒度"越小越好

```c
// 加锁 解锁
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t mutex;

void *tfn(void *arg) {
	srand(time(NULL));
	while (1) {
		pthread_mutex_lock(&mutex);
		printf("hello ");
		sleep(rand() % 3); // 模拟失去cpu
		printf("world\n");
		pthread_mutex_unlock(&mutex);
		sleep(rand() % 3);
	}
	return NULL;
}

int main() {
	pthread_t tid;
	srand(time(NULL));
	pthread_mutex_init(&mutex, NULL); // mutex = 1

	pthread_create(&tid, NULL, tfn, NULL);

	while (1) {
		pthread_mutex_lock(&mutex);
		printf("HELLO ");
		sleep(rand() % 3);
		printf("WORLD\n");
		pthread_mutex_unlock(&mutex);
		sleep(rand() % 3);
		
	}

	pthread_mutex_destroy(&mutex);
	return 0;
}
```

### 死锁
- 线程对同一个互斥量加锁两次
- 线程1拥有A锁，请求B锁；线程2拥有B锁，请求A锁

### 读写锁
写独占，读共享，写锁优先级高

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
int counter;
pthread_rwlock_t rwlock;

void *th_write(void *arg) {
	int t;
	int i = (int) arg;
	printf("i = %d\n", i);
	while (1) {
		t = counter;
		usleep(1000);
		pthread_rwlock_wrlock(&rwlock);
		printf("write %d: %lu: counter = %d ++counter = %d\n", i, pthread_self(), t, ++counter);
		pthread_rwlock_unlock(&rwlock);
		usleep(1000);
	}
	return NULL;
}

void *th_read(void *arg) {
	int i;
	i = (int) arg;
	while (1) {
		pthread_rwlock_rdlock(&rwlock);
		printf("read %d: %lu: counter = %d\n", i, pthread_self(), counter);
		pthread_rwlock_unlock(&rwlock);
		usleep(900);
	}
	return NULL;
}

void sys_err(char *s, int err) {
	fprintf(stderr, "%s error: %s\n", s, strerror(err));
	exit(1);
}
int main() {

	int i, ret;
	pthread_t tid[8];
	pthread_rwlock_init(&rwlock, NULL);
	
	// 创建3个写线程
	for (i = 0; i < 3; ++i) {
		ret = pthread_create(&tid[i], NULL, th_write, (void*)i);
		if (ret != 0) sys_err("pthread_create", ret);
	}
}
```
### 条件变量

```c
// 生产者消费者模型
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

struct msg{
	struct msg *next;
	int num;
};
struct msg *head, *mp;

void *consumer(void *arg) {
	while (1) {
		pthread_mutex_lock(&lock);
		while (head == NULL) { // 多个消费者, 只有一个能抢到资源
			pthread_cond_wait(&has_product, &lock);
		}
		mp = head;
		head = mp->next;
		pthread_mutex_unlock(&lock);

		printf("Consumer -- %d\n", mp->num);
		free(mp);
		mp = NULL;
		sleep(rand() % 3);
	}
}

void *producer(void *p) {
	while (1) {
		mp = malloc(sizeof(struct msg));
		mp->num = rand() % 100 + 1;
		printf("Producer ++ %d\n", mp->num);
		
		pthread_mutex_lock(&lock);
		mp->next = head;
		head = mp;
		pthread_mutex_unlock(&lock);
		// 唤醒等待的线程
		pthread_cond_signal(&has_product); 
		sleep(rand() % 3);
	}
}

int main() {
	pthread_t pid, cid;
	srand(time(NULL));

	pthread_create(&pid, NULL, producer, NULL);
	pthread_create(&cid, NULL, consumer, NULL);

	pthread_join(pid, NULL);
	pthread_join(cid, NULL);

	return 0;
}
```
## 信号量

信号量实现生产者消费模型
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#define NUM 5

int queue[NUM];
sem_t blank_number, product_number;

void *producer(void *arg) {
	int i = 0;
	while (1) {
		sem_wait(&blank_number);
		queue[i] = rand() % 100 + 1;
		printf("Produce ++ %d\n", queue[i]);
		sem_post(&product_number);

		i = (i + 1) % NUM;
		sleep(rand() % 1);
	}
}

void *consumer(void *arg) {
	int i = 0;
	while (1) {
		sem_wait(&product_number);
		printf("Consume -- %d\n", queue[i]);
		queue[i] = 0;
		i = (i + 1) % NUM;
		sleep(rand() % 3);
	}
}

int main() {
	pthread_t pid, cid;

	sem_init(&blank_number, 0, NUM);
	sem_init(&product_number, 0, 0);

	pthread_create(&pid, NULL, producer, NULL);
	pthread_create(&cid, NULL, consumer, NULL);

	pthread_join(pid, NULL);
	pthread_join(cid, NULL);

	sem_destroy(&blank_number);
	sem_destroy(&product_number);

	return 0;
}
```

### 进程同步

互斥量实现进程同步
```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

struct mt{
	int num;
	pthread_mutex_t mutex;
	pthread_mutexattr_t mutexattr;
};

int main() {
	int i;
	struct mt *mm;
	pid_t pid;

	mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);
	memset(mm, 0, sizeof(*mm));
	// 初始化mutex属性对象
	pthread_mutexattr_init(&mm->mutexattr);
	// 设置进程共享
	pthread_mutexattr_setpshared(&mm->mutexattr, PTHREAD_PROCESS_SHARED);
	// 初始化mutex锁
	pthread_mutex_init(&mm->mutex, &mm->mutexattr);

	pid = fork();
	if (pid == 0) {
		for (i = 0; i < 10; ++i) {
			pthread_mutex_lock(&mm->mutex);
			(mm->num)++;
			pthread_mutex_unlock(&mm->mutex);
			printf("child num++ %d\n", mm->num);

			sleep(1);
		}
	}else if(pid > 0) {
		for (i = 0; i < 10; ++i) {
			sleep(1);
			pthread_mutex_lock(&mm->mutex);
			mm->num += 2;
			printf("parent num +=2 %d\n", mm->num);
			pthread_mutex_unlock(&mm->mutex);
		}
		wait(NULL);
	}
	pthread_mutexattr_destroy(&mm->mutexattr);
	pthread_mutex_destroy(&mm->mutex);
	return 0;
}
```

文件锁
```c
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

void sys_err(char *s) {
	perror(s);
	exit(1);
}

int main(int argc, char *argv[]) {
	int fd;
	struct flock f_lock;
	if (argc < 2) {
		printf("./a.out filename\n");
		exit(1);
	}

	if ((fd = open(argv[1], O_RDWR)) < 0) {
		sys_err("open");
	}

	f_lock.l_type = F_WRLCK; // 写锁
	// f_lock.l_type = F_RDLCK; // 读锁
	
	f_lock.l_whence = SEEK_SET;
	f_lock.l_start = 0;
	f_lock.l_len = 0; // 0对整个文件加锁

	fcntl(fd, F_SETLKW, &f_lock);
	printf("get flock\n");
	sleep(10);

	f_lock.l_type = F_UNLCK;
	fcntl(fd, F_SETLKW, &f_lock);
	printf("un flock\n");

	close(fd);

	return 0;
}
```
## 网络编程

man 7 ip
nc localhost 6666 测试连接

接受客户端发送的字符，将小写转为大写发送给客户端

### 简单socket连接

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>
#define SERV_PORT 6666
int main() {

	int lfd, cfd, ret;
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	char buf[BUFSIZ], clie_IP[BUFSIZ];
	int n, i;
	// 创建套接字
	lfd = socket(AF_INET, SOCK_STREAM, 0);
	if (lfd == -1) {
		perror("socket error");
		exit(1);
	}

	// 端口复用
	int opt = 1;
	setsockopt(lfd, SOCK_STREAM, SO_REUSEADDR, &opt, sizeof(opt));

	// 设置协议，ip和端口
	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	// 绑定端口
	ret = bind(lfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
	if (ret == -1) {
		perror("bind error");
		exit(1);
	}
	// 设置同时连接的数量
	ret = listen(lfd, 128);
	if (ret == -1) {
		perror("listen error");
		exit(1);
	}
	
	clie_addr_len = sizeof(clie_addr);
	// 阻塞等待客户端连接
	cfd = accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
	if (cfd == -1) {
		perror("accept error");
		exit(1);
	}
	// 输出连接客户端的信息
	inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP));

	printf("client ip: %s, client port: %d\n", clie_IP, ntohs(clie_addr.sin_port));	
	while (1) {
		n = read(cfd, buf, sizeof(buf));
		for (i = 0; i < n; ++i) {
			buf[i] = toupper(buf[i]);
		}
		write(cfd, buf, n);
	}
	
	close(lfd);

	return 0;
}
```

客户端向服务器发送字符串, 接受服务端发送来的字符串
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#define SERV_PORT 6666
#define SERV_IP "127.0.0.1"

int main() {
	int cfd, n;
	struct sockaddr_in serv_addr;
	socklen_t serv_addr_len;
	serv_addr_len = sizeof(serv_addr);
	// 创建socket
	cfd = socket(AF_INET, SOCK_STREAM, 0);
		
	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	inet_pton(AF_INET, SERV_IP, &serv_addr.sin_addr.s_addr);
	// 链接服务器
	connect(cfd, (struct sockaddr *)&serv_addr, serv_addr_len);

	char buf[BUFSIZ];
	while (1) {
		fgets(buf, sizeof(buf), stdin);
		// 向服务端发送信息
		write(cfd, buf, strlen(buf));
		// 读取服务端发送的消息
		n = read(cfd, buf, sizeof(buf));
		write(STDOUT_FILENO, buf, n);
	}

	close(cfd);
	return 0;
}
```

### 多进程连接

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <strings.h>
#include <ctype.h>
#include "wrap.h"
#include <sys/wait.h>
#define SERV_PORT 8888

void wait_child(int signo) {
	while (waitpid(0, NULL, WNOHANG) > 0);
}

int main() {

	int lfd, cfd;
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	pid_t pid;
	char buf[BUFSIZ], clie_IP[BUFSIZ];
	int n, i;
	lfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	// inet_pton(AF_INET, "192.168.1.101", &serv_addr.sin_addr.s_addr);
	Bind(lfd, (struct scockaddr *)&serv_addr, sizeof(serv_addr));

	Listen(lfd, 128);

	while (1) {
		clie_addr_len = sizeof(clie_addr);
		cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
		
		printf("client IP: %s, client port: %d\n", 
		inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP)),
		ntohs(clie_addr.sin_port));
		pid = fork();
		if (pid < 0) {
			perror("fork error");
			exit(1);
		}else if (pid == 0) {
			close(lfd);
			break;
		}else {
			close(cfd);	
			signal(SIGCHLD, wait_child);
		}
	}
	if (pid == 0) {
		while (1) {
			n = Read(cfd, buf, sizeof(buf));
			if (n == 0) {
				return 0;
			}else if(n < 0) {
				perror("read error");
				exit(1);
			}else {
				for (i = 0; i < n; ++i) {
					buf[i] = toupper(buf[i]);
				}
				write(cfd, buf, n);
			}
		}
	}

	return 0;
}
```

### 多线程连接

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <strings.h>
#include <ctype.h>
#include "wrap.h"
#include <sys/wait.h>
#include <pthread.h>
#define SERV_PORT 8888

struct s_info{
	struct sockaddr_in addr;
	int cfd;
};

void *do_work(void *arg) {
	int n, i;
	struct s_info *ts = (struct s_info*) arg;
	char buf[BUFSIZ], clie_IP[BUFSIZ];
	while (1) {
		n = Read((*ts).cfd, buf, sizeof(buf));
		if (n == 0) {
			return 0;
		}else if(n < 0) {
			perror("read error");
			exit(1);
		}else {
			for (i = 0; i < n; ++i) {
				buf[i] = toupper(buf[i]);
			}
			printf("client IP: %s, client port: %d\n", 
			inet_ntop(AF_INET, &(*ts).addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP)),
			ntohs((*ts).addr.sin_port));
			
			write(STDOUT_FILENO, buf, n);
			write((*ts).cfd, buf, n);
		}
	}
}

int main() {
	int lfd, cfd;
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	lfd = Socket(AF_INET, SOCK_STREAM, 0);
	pthread_t tid;
	struct s_info ts[256];
	int i = 0;

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	// inet_pton(AF_INET, "192.168.1.101", &serv_addr.sin_addr.s_addr);
	Bind(lfd, (struct scockaddr *)&serv_addr, sizeof(serv_addr));

	Listen(lfd, 128);
	
	while (1) {
		clie_addr_len = sizeof(clie_addr);
		cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
		ts[i].addr = clie_addr;
		ts[i].cfd = cfd;
		
		pthread_create(&tid, NULL, do_work, (void*)&ts[i]);
		pthread_detach(tid);
		++i;
	}
	return 0;
}
```

### select实现并发

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <ctype.h>
#include "wrap.h"

#define SERV_PORT 6666

int main() {
	int i, j, n, maxi;
	// 自定义数组client，防止遍历1024个文件描述符
	int nread, client[FD_SETSIZE];
	int maxfd, listenfd, connfd, sockfd;
	// define INET_ADDRSTRLEN 16, IPV4在char表示的最大的长度
	char buf[BUFSIZ], str[INET_ADDRSTRLEN];
	struct sockaddr_in clie_addr, serv_addr;
	socklen_t clie_addr_len;
	fd_set rset, allset;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
	Listen(listenfd, 128);

	maxfd = listenfd;

	maxi = -1;
	for (i = 0; i < FD_SETSIZE; ++i) {
		client[i] = -1;
	}
	FD_ZERO(&allset);
	FD_SET(listenfd, &allset);

	while (1) {
		rset = allset;
		// 最大文件描述符+1，读文件描述符，写文件描述符， 异常文件描述符，等待时间
		nread = select(maxfd+1, &rset, NULL, NULL, NULL);
		if (nread < 0) {
			perror("select error");
			exit(1);
		}
		// 新的连接
		if (FD_ISSET(listenfd, &rset)) {
			clie_addr_len = sizeof(clie_addr);
			// Accept 不会阻塞
			connfd = Accept(listenfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
			printf("receive from %s at port %d\n", 
					inet_ntop(AF_INET, &clie_addr.sin_addr, str, sizeof(str)),
					ntohs(clie_addr.sin_port));
			// 把Accept返回的文件描述符保存到clientp[]中
			for (i = 0; i < FD_SETSIZE; ++i) {
				if (client[i] < 0) {
					client[i] = connfd;
					break;
				}
			}
			if (i == FD_SETSIZE) {
				fputs("too many clients\n", stderr);
				exit(1);
			}
			FD_SET(connfd, &allset);
			if (connfd > maxfd) {
				maxfd = connfd;
			}
			if (i > maxi) {
				maxi = i;
			}
			if (--nread == 0) {
				continue;
			}
		}
		for (int i = 0; i <= maxi; ++i) {
			if ((sockfd = client[i]) < 0) continue;
			if (FD_ISSET(sockfd, &rset)) {
				// 客户端关闭
				if ((n = Read(sockfd, buf, sizeof(buf))) == 0) {
					close(sockfd);
					FD_CLR(sockfd, &allset);
					client[i] = -1;
				}else if (n > 0) {
					for (j = 0; j < n; ++j) {
						buf[j] = toupper(buf[j]);
					}
					// sleep(5);
					Writen(sockfd, buf, n);
				}
				if (--nread == 0) break;
			}
		}
	}
	Close(listenfd);
	return 0;
}
```
### poll实现并发

```bash
# 查看进程可以打开socket描述符的上限
cat /proc/sys/fs/file-max 
# 修改上限值
vim /etc/security/limits.conf 
# 尾部添加soft软限制，hard硬限制
* soft nofile 65536
* hard nofile 100000
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <poll.h>
#include <string.h>
#include <netinet/in.h>
#include <errno.h>
#include "wrap.h"
#define SERV_PORT 6666
#define MAXLINE 80
#define OPEN_MAX 1024
int main() {
	int i, j, maxi, listenfd, connfd, sockfd;
	int nready;
	ssize_t n;
	
	char buf[BUFSIZ], str[INET_ADDRSTRLEN];
	socklen_t clien;
	struct pollfd client[OPEN_MAX];
	struct sockaddr_in servaddr, clieaddr;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	// 设置端口复用
	int opt = 1;
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));
	Listen(listenfd, 128);

	client[0].fd = listenfd;
	client[0].events = POLLIN;
	for (i = 1; i < OPEN_MAX; ++i) {
		client[i].fd = -1;
	}
	maxi = 0;
	while (1) {
		// 阻塞监听是否有新的链接请求
		nready = poll(client, maxi+1, -1);
		if (client[0].revents & POLLIN) {
			clien = sizeof(clieaddr);
			connfd = Accept(listenfd, (struct sockaddr *)&clieaddr, &clien);
			printf("received from %s at PORT %d\n",
					inet_ntop(AF_INET, &clieaddr.sin_addr, str, sizeof(str)),
					ntohs(clieaddr.sin_port));
			// 把Accept返回的connfd，放到client[]中
			for (i = 1; i < OPEN_MAX; ++i) {
				if (client[i].fd < 0) {
					client[i].fd = connfd;
					break;
				}
			}
			
			if (i == OPEN_MAX) {
				perror("too many clients");
				exit(1);
			}
			// 监听新连接的客户端的读时间
			client[i].events = POLLIN;
			// 更新client[]中的最大下标
			if (i > maxi) maxi = i;
			// 判断时候有读写事件
			if (--nready == 0) continue;
		}

		// 找到对应的客户端，处理请求
		for (i = 1; i <= maxi; ++i) {
			if ((sockfd = client[i].fd) < 0) {
				continue;
			}

			if (client[i].revents & POLLIN) {
				if ((n = Read(sockfd, buf, MAXLINE)) < 0) {
					// 连接重置
					if (errno == ECONNRESET) {
						printf("client[%d] aborted connection\n", i);
						Close(sockfd);
						client[i].fd = -1;
					}else {
						perror("read error");
						exit(1);
					}
				}else if (n == 0) {
					printf("client[%d] closed connection\n", i);
					Close(sockfd);
					client[i].fd = -1;
				}else {
					for (j = 0; j < n; ++j) {
						buf[j] = toupper(buf[j]);
					}
					Writen(sockfd, buf, n);
				}
				if (--nready == 0) break;
			}
		}
	}
	return 0;
}
```
### epoll实现并发

epoll_create();
epoll_ctl();
epoll_wait();

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <sys/epoll.h>
#include <string.h>
#include <netinet/in.h>
#include <errno.h>
#include "wrap.h"
#define SERV_PORT 6666
#define MAXLINE 8000
#define OPEN_MAX 5000
int main() {
	int i, j, listenfd, connfd, sockfd;
	int n;
	ssize_t nready, efd, res;
	char buf[MAXLINE], str[INET_ADDRSTRLEN];
	socklen_t clilen;
	struct sockaddr_in cliaddr, servaddr;
	struct epoll_event tep, ep[OPEN_MAX];

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	int opt = 1;
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));
	Listen(listenfd, 128);
	// 创建epoll模型，edf指向红黑树的根节点
	efd = epoll_create(OPEN_MAX);
	if (efd == -1) {
		perror("epoll create");
		exit(1);
	}
	// listenfd为监听的读事件
	tep.events = EPOLLIN;
	tep.data.fd = listenfd;
	// 将listenfd插到epoll树上
	res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &tep);
	if (res == -1) {
		perror("epoll_ctl error");
		exit(1);
	}
	while (1) {
		nready = epoll_wait(efd, ep, OPEN_MAX, -1);
		if (nready == -1) {
			perror("epoll_wait error");
			exit(1);
		}
		for (i = 0; i < nready; ++i) {
			if (!(ep[i].events & EPOLLIN)) {
				continue;
			}
			if (ep[i].data.fd == listenfd) {
				clilen = sizeof(cliaddr);
				connfd = Accept(listenfd, (struct sockaddr *)&cliaddr, &clilen);
				printf("reveived from %s at port %d\n", 
						inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)),
						ntohs(cliaddr.sin_port));
				tep.events = EPOLLIN;
				tep.data.fd = connfd;
				res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &tep);
				if (res == -1) {
					perror("epoll_ctl error");
					exit(1);
				}
			}else {
				sockfd = ep[i].data.fd;
				n = Read(sockfd, buf, MAXLINE);
				if (n == 0) {
					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);
					if (res == -1) {
						perror("epoll_ctl error");
						exit(1);
					} 
					printf("client[%d] close connection\n", sockfd);
					Close(sockfd);
				} else if (n > 0) {
					for (j = 0; j < n; ++j) {
						buf[j] = toupper(buf[j]);
					}
					Writen(sockfd, buf, n);
					Writen(STDOUT_FILENO, buf, n);
				}else if (n < 0) {
					perror("read error");
					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);
					if (res == -1) {
						perror("epoll_ctl DEL error");
						exit(1);
					}
					Close(sockfd);
				}
			}
		}
	}


	return 0;
}
```
### epoll 水平触发和边沿触发

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <errno.h>
#include <unistd.h>
#define MAXLINE 10

int main() {
	
	int efd, i;
	int pfd[2];
	pid_t pid;
	char buf[MAXLINE], ch = 'a';

	pipe(pfd);
	pid = fork();
	// 子写，父读
	if (pid == 0) {
		close(pfd[0]);
		while (1) {
			for (i = 0; i < MAXLINE/2; ++i) {
				buf[i] = ch;
			}
			buf[i-1] = '\n';
			ch++;
			for (; i < MAXLINE; ++i) {
				buf[i] = ch; 
			}
			buf[i-1] = '\n';
			ch++;
			write(pfd[1], buf, sizeof(buf));
			sleep(3);
		}
		close(pfd[1]);
	} else if(pid > 0) {
		struct epoll_event event;
		struct epoll_event resevent[10];
		int res, len;

		close(pfd[1]);
		efd = epoll_create(10);

		event.events = EPOLLIN | EPOLLET; // ET边沿触发
		// event.events = EPOLLIN; // LT水平触发(默认)
		event.data.fd = pfd[0];
		res = epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &event);
		if (res == -1) {
			perror("epoll_ctl error");
			exit(1);
		}

		while (1) {
			res = epoll_wait(efd, resevent, 10, -1);
			printf("res %d\n", res);
			if (resevent[0].data.fd == pfd[0]) {
				len = read(pfd[0], buf, MAXLINE/2);
				write(STDOUT_FILENO, buf, len);
			}
		}
	}
	
	return 0;
}
```

### epoll 非阻塞IO
使用边沿epoll，减少epoll_wait
while读取数据
fcntl设置非阻塞读

```c
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/epoll.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>

#define MAXLINE 10
#define SERV_PORT 6666
#define SERV_IP "127.0.0.1"

int main() {
	struct sockaddr_in servaddr, cliaddr;
	socklen_t cliaddr_len;
	int listenfd, connfd;
	char buf[BUFSIZ];
	char str[INET_ADDRSTRLEN];
	int efd, flag;
	
	listenfd = socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	inet_pton(AF_INET, SERV_IP, &servaddr.sin_addr.s_addr);
	// servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);
	
	bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));

	listen(listenfd, 20);

	cliaddr_len = sizeof(cliaddr);
	connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &cliaddr_len);
	printf("receive from %s port %d\n", inet_ntop(AF_INET, &cliaddr.sin_family, str, sizeof(str)),
			ntohs(cliaddr.sin_port));

	// 修改connfd为非阻塞读
	flag = fcntl(connfd, F_GETFL);
	flag |= O_NONBLOCK;
	fcntl(connfd, F_SETFL, flag);

	struct epoll_event event;
	struct epoll_event resevent[10];
	int res, len;
	
	efd = epoll_create(10);
	event.events = EPOLLIN | EPOLLET;
	event.data.fd = connfd;

	epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &event);
	while (1) {
		printf("epoll_wait...\n");
		res = epoll_wait(efd, resevent, 10, -1);
		printf("epoll_wait end res %d\n", res);

		if (resevent[0].data.fd == connfd) {
			while ((len = read(connfd, buf, MAXLINE/2)) > 0) {
				write(STDOUT_FILENO, buf, len);
			}
		}
	}

	return 0;
}
```

### epoll 基于非阻塞I/O事件驱动 (反应堆模型)
libevent的核心思想

1. epoll
服务器监听fd, 可读epoll返回, read之后处理数据, write写回, epoll继续监听

2. epoll反应堆模型
服务器监听cfd, 可读epoll返回, read之后将cfd从树上摘下, 设置epoll监听的写事件, 处理数据, 等待epoll_wait返回写回客户端, 将cfd从树上摘下, 设置cfd的读事件继续监听

```c
// epoll_loop.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <time.h>

#define MAX_EVENTS 1024
#define BUFLEN 4096
#define SERV_PORT 6666

void recvdata(int fd, int events, void *arg);
void senddata(int fd, int events, void *arg);

// 描述就绪文件描述符相关信息
struct myevent_s{
	int fd;
	int events;
	void *arg;											// 泛型指针
	void (*call_back)(int fd, int events, void *arg);	// 回调函数
	int status;											// 是否在监听 1->在红黑树上, 0->不在红黑树上
	char buf[BUFLEN];
	int len;
	long last_active;									// 记录每次加入红黑树上 g_efd 的时间值
};

int g_efd;												// 保存epoll_create返回的文件描述符
struct myevent_s g_events[MAX_EVENTS+1];				// 自定义结构体类型数组, +1->listenfd

// 初始化myevent_s 成员变量
void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg) {
	ev->fd = fd;
	ev->call_back = call_back;
	ev->events = 0;
	ev->arg = arg;
	ev->status = 0;
	// memset(ev->buf, 0, sizeof(ev->buf));
	// ev->len = 0;
	ev->last_active = time(NULL);
	return;
}

// 向epoll监听的红黑树插入文件描述符
void eventadd(int efd, int events, struct myevent_s *ev) {
	struct epoll_event epv = {0, {0}};
	int op;
	epv.data.ptr = ev;
	epv.events = ev->events = events;

	if (ev->status == 1) {
		op = EPOLL_CTL_MOD;
	}else {
		op = EPOLL_CTL_ADD;
		ev->status = 1;
	}

	if (epoll_ctl(efd, op, ev->fd, &epv) < 0) {
		printf("event add faild [fd=%d], events[%d]\n", ev->fd, events);
	}else {
		printf("event add OK [fd=%d], op = %d, events[%0X]\n", ev->fd, op, events);
	}
	return;
}

// 从epoll监听的红黑树删除文件描述符
void eventdel(int efd, struct myevent_s *ev) {
	struct epoll_event epv = {0, {0}};
	if (ev->status != 1) {
		return;
	}
	epv.data.ptr = ev;
	ev->status = 0;
	epoll_ctl(efd, EPOLL_CTL_DEL, ev->fd, &epv);
	return;
}

// 当文件描述符就绪, epoll返回, 调用函数与客户端建立连接
void acceptconn(int lfd, int events, void *arg) {
	struct sockaddr_in cin;
	socklen_t len = sizeof(cin);
	int cfd, i;

	if ((cfd = accept(lfd, (struct sockaddr *)&cin, &len)) == -1) {
		if (errno != EAGAIN && errno != EINTR) {
			// 出错处理
		}
		printf("%s: accept, %s\n", __func__, strerror(errno));
		return;
	}

	do{
		// 在g_events中为cfd找个位置存
		for (i = 0; i < MAX_EVENTS; ++i) {
			if(g_events[i].status == 0) {
				break;
			}
			if (i == MAX_EVENTS) {
				printf("%s: max connect limit[%d]\n", __func__, MAX_EVENTS);
				break;
			}
		}
		int flag = 0;
		if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) < 0) {
			printf("%s: fcntl nonblocking failed, %s\n", __func__, strerror(errno));
			break;
		}
		// 给cfd设置一个myevent_s的结构体, 回调函数设置为recvdata
		eventset(&g_events[i], cfd, recvdata, &g_events[i]);
		eventadd(g_efd, EPOLLIN, &g_events[i]);
	}while (0);
	
	printf("new connect [%s:%d][time:%ld], pos[%d]\n",
		inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);
	return;
}

void recvdata(int fd, int events, void *arg) {
	struct myevent_s *ev = (struct myevent_s *) arg;
	int len;
	len = recv(fd, ev->buf, sizeof(ev->buf), 0);

	eventdel(g_efd, ev);				// 删除fd

	if (len > 0) {
		ev->len = len;
		ev->buf[len] = '\0';
		printf("C[%d]:%s\n", fd, ev->buf);

		// printf("send before set len = %d %s\n", ev->len, ev->buf);
		eventset(ev, fd, senddata, ev);	// 设置fd的回调函数为senddata
		// printf("send before add len = %d %s\n", ev->len, ev->buf);
		eventadd(g_efd, EPOLLOUT, ev);	// 将fd加到红黑树上, 监听写事件
	}else if(len == 0) {
		close(ev->fd);
		eventdel(g_efd, ev);
		printf("[fd=%d] pos[%ld] closed\n", fd, ev - g_events);
	}else {
		close(ev->fd);
		eventdel(g_efd, ev);
		printf("recv[fd=%d] error[%d]:%s\n", fd, errno, strerror(errno));
	}
	return;
}

void senddata(int fd, int events, void *arg) {
	struct myevent_s *ev = (struct myevent_s *) arg;
	int len;
	// printf("send len ======= %d, %s\n", ev->len, ev->buf);
	len = send(fd, ev->buf, ev->len, 0); // 将数据写回客户端
	if (len > 0) {
		printf("send[fd=%d], [%d]%s\n", fd, len, ev->buf);
		eventdel(g_efd, ev);			// 删除fd
		eventset(ev, fd, recvdata, ev);	// 修改fd为读事件
		eventadd(g_efd, EPOLLIN, ev);	// 向红黑树上插入fd的读事件
	}else {
		close(ev->fd);
		eventdel(g_efd, ev);
		printf("send[fd=%d] error %s\n", fd, strerror(errno));
	}
	return;
}

// 创建socket, 初始化lfd
void initlistensocket(int efd, short port) {
	int lfd = socket(AF_INET, SOCK_STREAM, 0);
	fcntl(lfd, F_SETFL, O_NONBLOCK); // 设置socket为非阻塞
	eventset(&g_events[MAX_EVENTS], lfd, acceptconn, &g_events[MAX_EVENTS]);
	eventadd(efd, EPOLLIN, &g_events[MAX_EVENTS]);

	struct sockaddr_in sin;
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_port = htons(port);
	bind(lfd, (struct sockaddr *)&sin, sizeof(sin));
	listen(lfd, 20);
	return;
}

int main(int argc, char *argv[]) {
	unsigned short port = SERV_PORT;
	if (argc == 2) {
		port = atoi(argv[1]);
	}
	g_efd = epoll_create(MAX_EVENTS+1);	// 创建红黑树, g_efd
	if (g_efd <= 0) {
		printf("create efd in %s err %s\n", __func__, strerror(errno));
	}
	initlistensocket(g_efd, port);		// 初始化监听socket
	struct epoll_event events[MAX_EVENTS+1];	// 保存满足条件的就绪事件的文件描述符集合
	printf("server running:port[%d]\n", port);

	int checkpos = 0, i;
	while (1) {
		// 超时验证, 每次测试100个链接, 不测试listenfd.
		// 当客户端在60秒内没有和服务器通信, 关闭客户端的链接
		long now = time(NULL);
		for (i = 0; i < 100; ++i, ++checkpos) {
			if (checkpos == MAX_EVENTS) checkpos = 0;
			if (g_events[checkpos].status == 0) continue;

			long duration = now - g_events[checkpos].last_active; // 计算客户不活跃的时间
			if (duration >= 60) {
				close(g_events[checkpos].fd);					  // 关闭客户端的连接
				eventdel(g_efd, &g_events[checkpos]);			  // 将对应的文件描述符从红黑树上删除
				printf("[fd=%d] timeout\n", g_events[checkpos].fd);
			}
		}

		// 监听红黑树, 将满足的事件的文件描述符加到events数组中, 1秒没有事件满足返回0
		int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);
		if (nfd < 0) {
			printf("epoll wait error, exit\n");
			break;
		}

		for (i = 0; i < nfd; ++i) {
			struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;
			if ((events[i].events & EPOLLIN) && (ev->events & EPOLLIN)) { // 读事件
				ev->call_back(ev->fd, events[i].events, ev->arg);
			}
			if ((events[i].events & EPOLLOUT) && (ev->events & EPOLLOUT)) { // 写事件
				ev->call_back(ev->fd, events[i].events, ev->arg);
			}
		}
	}
	return 0;
}
```
### 进程池

设置线程池的最小值和最大值, 开始默认创建最小值个线程, 阻塞等待条件变量任务队列不为空.
维护任务队列, 将客户端的连接加到任务队列中, 同时唤醒等待的线程.
线程唤醒之后任务队列中的任务, 并发出任务队列不为满的信号, 让阻塞的客户端继续放任务
管理者线程每隔一段时间, 对当前线程进行管理
 - 当任务队列中的任务数量 > 最小的线程数 且 存活的线程数 < 最小线程数 时按照步长创建新的线程
 - 当忙线程的数量 * 2 < 存活的线程数 且 存活的线程数 > 最小线程数 时按照步长销毁线程

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include "threadpool.h"

#define DEFAULT_TIME 10					// 10s检测一次
#define MIN_WAIT_TASK_NUM 10			// 如果queue_size > MIN_WAIT_TASK_NUM 添加新的线程到线程池
#define DEFAULT_THREAD_VARY 10				// 每次创建和销毁线程的个数
#define true 1
#define false 0
typedef struct{
	void *(*function)(void *);			// 函数指针, 回调函数
	void *arg;							// 函数的参数
}threadpool_task_t;						// 子线程的任务结构体

// 描述线程的相关信息
struct threadpool_t{
	pthread_mutex_t lock;				// 用于锁住结构体
	pthread_mutex_t thread_counter;		// 记录忙状态线程的个数的锁
	pthread_cond_t queue_not_full;		// 当任务队列为满, 添加任务的线程阻塞, 等待此条件变量
	pthread_cond_t queue_not_empty;		// 任务队队列不为空是, 通知等待任务的线程

	pthread_t *threads;					// 存放线程池中的每个线程的tid
	pthread_t adjust_tid;				// 管理者线程
	threadpool_task_t *task_queue;		// 任务队列

	int min_thr_num;					// 线程池最小线程数
	int max_thr_num;					// 线程池最大线程数
	int live_thr_num;					// 当前存活的线程数
	int busy_thr_num;					// 忙线程的个数
	int wait_exit_thr_num;				// 要销毁线程的个数

	int queue_front;					// 任务队列的队首
	int queue_rear;						// 任务队列的对位
	int queue_size;						// 任务队列中的实际任务数量
	int queue_max_size;					// 任务队列可容纳的最大任务数
	
	int shutdown;						// 标志位, 线程池的使用状态
};

void *threadpool_thread(void *threadpool);
void *adjust_thread(void *threadpool);
int is_thread_alive(pthread_t tid);
int threadpool_free(threadpool_t *pool);

threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size) 
{
	int i;
	threadpool_t *pool = NULL;
	do{
		if ((pool = (threadpool_t *)malloc(sizeof(threadpool_t))) == NULL) {
			printf("malloc threadpool fail\n");
			break;
		}

		pool->min_thr_num = min_thr_num;
		pool->max_thr_num = max_thr_num;
		pool->busy_thr_num = 0;
		pool->live_thr_num = min_thr_num;
		pool->queue_size = 0;
		pool->queue_max_size = queue_max_size;
		pool->queue_front = 0;
		pool->queue_rear = 0;
		pool->shutdown = false;

		// 更具最大线程上限数, 创建工作线程数组并清零
		pool->threads = (pthread_t*) malloc(sizeof(pthread_t) * max_thr_num);
		if (pool->threads == NULL) {
			printf("malloc threads fail\n");
			break;
		}
		memset(pool->threads, 0, sizeof(pthread_t) * max_thr_num);

		// 为任务队列开辟空间
		pool->task_queue = (threadpool_task_t *) malloc(sizeof(threadpool_task_t) * queue_max_size);
		if (pool->task_queue == NULL) {
			printf("malloc task_queue fail\n");
			break;
		}

		// 初始化互斥锁, 条件变量
		if (pthread_mutex_init(&(pool->lock), NULL) != 0 ||
			pthread_mutex_init(&(pool->thread_counter), NULL) != 0 ||
			pthread_cond_init(&(pool->queue_not_full), NULL) != 0 ||
			pthread_cond_init(&(pool->queue_not_empty), NULL) != 0)
		{
			printf("init the lock or cond fail\n");
			break;
		}

		// 创建待命的线程
		for (i = 0; i < min_thr_num; ++i) {
			pthread_create(&(pool->threads[i]), NULL, threadpool_thread, (void *)pool);
			printf("start thread 0x%x...\n", (unsigned int)pool->threads[i]);
		}
		// 创建管理者线程
		pthread_create(&(pool->adjust_tid), NULL, adjust_thread, (void *)pool);

		return pool;
	}while(0);

	threadpool_free(pool);
	return NULL;
}


// 向线程池中添加一个任务
int threadpool_add(threadpool_t *pool, void *(*function)(void *arg), void *arg) 
{
	pthread_mutex_lock(&(pool->lock));
	// 队列已满, wait阻塞
	while ((pool->queue_size == pool->queue_max_size) && (!pool->shutdown)) {
		pthread_cond_wait(&(pool->queue_not_full), &(pool->lock));
	}
	if (pool->shutdown) {
		pthread_mutex_unlock(&(pool->lock));
	}

	// 清空工作线程, 调用回调函数
	if (pool->task_queue[pool->queue_rear].arg != NULL) {
		free(pool->task_queue[pool->queue_rear].arg);
		pool->task_queue[pool->queue_rear].arg = NULL;
	}

	// 添加任务到任务队列中
	pool->task_queue[pool->queue_rear].function = function;
	pool->task_queue[pool->queue_rear].arg = arg;
	pool->queue_rear = (pool->queue_rear + 1) % pool->queue_max_size;
	pool->queue_size++;

	// 添加任务后队列不为空, 唤醒线程池中等待的线程
	pthread_cond_signal(&(pool->queue_not_empty));
	pthread_mutex_unlock(&(pool->lock));
	return 0;
}

// 线程池中工作的线程
void *threadpool_thread(void *threadpool) 
{
	threadpool_t *pool = (threadpool_t *)threadpool;
	threadpool_task_t task;

	while (true) {
		pthread_mutex_lock(&(pool->lock));
		
		// 刚创建的线程阻塞等待任务队列有任务在唤醒处理任务
		while((pool->queue_size == 0) && (!pool->shutdown)) {
			printf("thread 0x%x is waitting\n", (unsigned int)pthread_self());
			pthread_cond_wait(&(pool->queue_not_empty), &(pool->lock));
			// 清除指定数目的空闲线程, 如果结束的线程个数大于0, 结束线程
			if (pool->wait_exit_thr_num > 0) {
				pool->wait_exit_thr_num--;
				if (pool->live_thr_num > pool->min_thr_num) {
					printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
					pool->live_thr_num--;
					pthread_mutex_unlock(&(pool->lock));
					pthread_exit(NULL);
				}
			}
		}
		
		// 关闭线程池
		if (pool->shutdown) {
			pthread_mutex_unlock(&(pool->lock));
			printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
			pthread_exit(NULL);
		}

		// 从任务队列中获取任务, 出队
		task.function = pool->task_queue[pool->queue_front].function;
		task.arg = pool->task_queue[pool->queue_front].arg;
		pool->queue_front = (pool->queue_front + 1) % pool->queue_max_size;
		pool->queue_size--;
		
		// 通知可以有新的任务进来
		pthread_cond_broadcast(&(pool->queue_not_full));
		
		// 取出任务之后, 释放线程锁
		pthread_mutex_unlock(&(pool->lock));

		// 执行任务
		printf("thread 0x%x start working\n", (unsigned int)pthread_self());
		pthread_mutex_lock(&(pool->thread_counter));
		pool->busy_thr_num++;
		pthread_mutex_unlock(&(pool->thread_counter));
		// 执行回调函数
		(*(task.function))(task.arg);
		
		printf("thread 0x%x end working\n", (unsigned int)pthread_self());
		pthread_mutex_lock(&(pool->thread_counter));
		pool->busy_thr_num--;
		pthread_mutex_unlock(&(pool->thread_counter));
	}
	pthread_exit(NULL);
}

// 管理线程
void *adjust_thread(void *threadpool) 
{
	int i;
	threadpool_t *pool = (threadpool_t*) threadpool;
	while (!pool->shutdown) {
		sleep(DEFAULT_TIME); 	// 定时对线程池进行管理

		pthread_mutex_lock(&(pool->lock));
		int queue_size = pool->queue_size;
		int live_thr_num = pool->live_thr_num;
		pthread_mutex_unlock(&(pool->lock));

		pthread_mutex_lock(&(pool->thread_counter));
		int busy_thr_num = pool->busy_thr_num;
		pthread_mutex_unlock(&(pool->thread_counter));

		// 创建新线程
		// 当任务数 > 最小线程个数 && 存活的线程数 < 最大线程个数
		if (queue_size >= MIN_WAIT_TASK_NUM &&  live_thr_num < pool->max_thr_num) {
			pthread_mutex_lock(&(pool->lock));
			int add = 0;
			
			// 每次增加DEFAULT_THREAD个线程
			for (i = 0; i < pool->max_thr_num && add < DEFAULT_THREAD_VARY && live_thr_num < pool->max_thr_num; ++i) {
				if (pool->threads[i] == 0 || !is_thread_alive(pool->threads[i])) {
					pthread_create(&(pool->threads[i]), NULL, threadpool_thread, (void*)pool);
					add++;
					pool->live_thr_num++;
				}
			}
			
			pthread_mutex_unlock(&(pool->lock));
		}

		// 清理线程
		// 忙线程 * 2 < 存活的线程 && 存活线程数 > 最小线程数
		if ((busy_thr_num * 2) < live_thr_num && live_thr_num > pool->min_thr_num) {
			pthread_mutex_lock(&(pool->lock));
			pool->wait_exit_thr_num = DEFAULT_THREAD_VARY;
			pthread_mutex_unlock(&(pool->lock));
			for (i = 0; i < DEFAULT_THREAD_VARY; ++i) {
				// 唤醒空闲的线程, 让他们自杀...
				pthread_cond_signal(&(pool->queue_not_empty));
			}
		}
	}
	return NULL;
}

int threadpool_destroy(threadpool_t *pool) 
{
	int i;
	if (pool == NULL) {
		return -1;
	}
	pool->shutdown = true;

	// 销毁管理线程
	pthread_join(pool->adjust_tid, NULL);
	
	for (i = 0; i < pool->live_thr_num; ++i) {
		pthread_cond_broadcast(&(pool->queue_not_empty));
	}
	for (i = 0; i < pool->live_thr_num; ++i) {
		pthread_join(pool->threads[i], NULL);
	}
	threadpool_free(pool);
	return 0;
}

int threadpool_free(threadpool_t *pool) 
{
	if (pool == NULL) {
		return -1;
	}
	if (pool->task_queue) {
		free(pool->task_queue);
	}
	if (pool->threads) {
		free(pool->threads);
		pthread_mutex_lock(&(pool->lock));
		pthread_mutex_destroy(&(pool->lock));
		pthread_mutex_lock(&(pool->thread_counter));
		pthread_mutex_destroy(&(pool->thread_counter));
		pthread_cond_destroy(&(pool->queue_not_empty));
		pthread_cond_destroy(&(pool->queue_not_full));
	}
	free(pool);
	pool = NULL;
	return 0;
}

int threadpool_all_threadnum(threadpool_t *pool) 
{
	int all_threadnum = -1;
	pthread_mutex_lock(&(pool->lock));
	all_threadnum = pool->live_thr_num;
	pthread_mutex_unlock(&(pool->lock));
	return all_threadnum;
}

int threadpool_busy_threadnum(threadpool_t *pool) 
{
	int busy_threadnum = -1;
	pthread_mutex_lock(&(pool->thread_counter));
	busy_threadnum = pool->busy_thr_num;
	pthread_mutex_unlock(&(pool->thread_counter));
	return busy_threadnum;
}

int is_thread_alive(pthread_t tid) 
{
	// 发送0信号, 测试线程是否存活
	int kill_rc = pthread_kill(tid, 0);
	if (kill_rc == ESRCH) return false;
	return true;
}

// 测试

#if 1

void *process(void *arg) 
{
	printf("thread 0x%x working on task %d\n", (unsigned int)pthread_self(), *(int*)arg);
	sleep(1);
	printf("task %d is end\n", *(int*)arg);
	return NULL;
}

int main() {

	threadpool_t *thp = threadpool_create(3, 100, 100);
	printf("pool inited\n");
	sleep(3);

	int num[20], i;
	for (i = 0; i < 20; ++i) {
		num[i] = i;
		printf("add task %d\n", i);
		// 向线程池添加任务
		threadpool_add(thp, process, (void*)&num[i]);
	}

	sleep(10);
	threadpool_destroy(thp);
	return 0;
}

#endif
```

## UDP

### C/S模型

```c
// server.c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>

#define SERV_PORT 6666

int main() {
	
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	int sockfd;
	char buf[BUFSIZ];
	char str[INET_ADDRSTRLEN];
	int i, n;

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(SERV_PORT);
	
	bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

	printf("Accepting connections ...\n");

	while (1) {
		clie_addr_len = sizeof(clie_addr);
		n = recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&clie_addr, &clie_addr_len);
		if (n == -1) {
			perror("recvfrom error");
			exit(1);
		}

		printf("received from %s at port %d\n",
				inet_ntop(AF_INET, &clie_addr, str, sizeof(str)),
				ntohs(clie_addr.sin_port));

		for (i = 0; i < n; ++i) {
			buf[i] = toupper(buf[i]);
		}

		n = sendto(sockfd, buf, n, 0, (struct sockaddr *)&clie_addr, sizeof(clie_addr));
		if (n == -1) {
			perror("sendto error");
			exit(1);
		}
	}
	close(sockfd);

	return 0;
}
```

```c
// client.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>
#include <ctype.h>

#define SERV_PORT 6666

int main() {
	struct sockaddr_in servaddr;
	int sockfd, n;
	char buf[BUFSIZ];

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr);
	servaddr.sin_port = htons(SERV_PORT);

	while (fgets(buf, BUFSIZ, stdin) != NULL) {
		n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&servaddr, sizeof(servaddr));
		if (n == -1) {
			perror("sendto error");
		}

		n = recvfrom(sockfd, buf, BUFSIZ, 0, NULL, 0);	// NULL 不关心对端信息
		if (n == -1) {
			perror("recvfrom error");
		}

		write(STDOUT_FILENO, buf, n);
	}
	return 0;
}
```

### 广播

```c
//server.c
#include <stdio.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define SERVER_PORT 6666
#define MAXLINE 1500
#define BROADCAST_IP "192.168.154.255"
#define CLIENT_PORT 7777

int main() {
	int sockfd;
	struct sockaddr_in serveraddr, clientaddr;
	char buf[BUFSIZ];

	// 构造UDP的套接字
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	bzero(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVER_PORT);
	
	bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));

	int flag = 1;
	// 设置套接字广播权限
	setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &flag, sizeof(flag));
	
	//设置client地址, IP+port 192.168.154.255+7777
	bzero(&clientaddr, sizeof(clientaddr));
	clientaddr.sin_family = AF_INET;
	inet_pton(AF_INET, BROADCAST_IP, &clientaddr.sin_addr.s_addr);
	clientaddr.sin_port = htons(CLIENT_PORT);

	int i = 0;
	while (1) {
		sprintf(buf, "Drink %d glasses of water\n", ++i);
		// fgets(buf, sizeof(buf), stdin);
		int ret = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&clientaddr, sizeof(clientaddr));
		if (ret == -1) {
			perror("sendto error");
			exit(1);
		}
		sleep(1);
	}

	close(sockfd);

	return 0;
}
```

```c
//client.c
#include <stdio.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>

#define SERVER_PORT 6666
#define MAXLINE 4096
#define CLIENT_PORT 7777

int main() {
	struct sockaddr_in localaddr;
	int confd;
	ssize_t len;
	char buf[MAXLINE];

	confd = socket(AF_INET, SOCK_DGRAM, 0);
	bzero(&localaddr, sizeof(localaddr));
	localaddr.sin_family = AF_INET;
	inet_pton(AF_INET, "0.0.0.0", &localaddr.sin_addr.s_addr);
	localaddr.sin_port = htons(CLIENT_PORT);

	int ret = bind(confd, (struct sockaddr *)&localaddr, sizeof(localaddr));
	if (ret == 0) {
		printf("..bind ok ...\n");
	}
	while (1) {
		len = recvfrom(confd, buf, sizeof(buf), 0, NULL, 0);
		write(STDOUT_FILENO, buf, len);
	}
	
	close(confd);
	return 0;
}
```

### 组播


```bash
# 查看网卡编号
ip ad
```
```c
//server.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <net/if.h>

#define SERVER_PORT 6666
#define CLIENT_PORT 7777
#define MAXLINE 1500
#define GROUP "239.0.0.2"

int main() {
	int sockfd;
	struct sockaddr_in serveraddr, clientaddr;
	char buf[MAXLINE] = "kali@root\n";
	struct ip_mreqn group;
	
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	bzero(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVER_PORT);

	bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));
	// 设置组地址
	inet_pton(AF_INET, GROUP, &group.imr_multiaddr);
	// 指定本机地址
	inet_pton(AF_INET, "0.0.0.0", &group.imr_address);
	// 获取eth0对应网卡的编号
	group.imr_ifindex = if_nametoindex("eth0");

	// 组播权限
	setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &group, sizeof(group));

	bzero(&clientaddr, sizeof(clientaddr));
	clientaddr.sin_family = AF_INET;
	inet_pton(AF_INET, GROUP, &clientaddr.sin_addr.s_addr);
	clientaddr.sin_port = htons(CLIENT_PORT);

	int i = 0;
	while (1) {
		sprintf(buf, "kali@root %d\n", ++i);
		sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&clientaddr, sizeof(clientaddr));
		sleep(1);
	}
	
	close(sockfd);
	return 0;
}
```

```c
//client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <net/if.h>

#define SERVER_PORT 6666
#define CLIENT_PORT 7777
#define GROUP "239.0.0.2"

int main() {
	struct sockaddr_in localaddr;
	int confd;
	ssize_t len;
	char buf[BUFSIZ];

	struct ip_mreqn group;

	confd = socket(AF_INET, SOCK_DGRAM, 0);
	
	bzero(&localaddr, sizeof(localaddr));
	localaddr.sin_family = AF_INET;
	inet_pton(AF_INET, "0.0.0.0", &localaddr.sin_addr.s_addr);
	localaddr.sin_port = htons(CLIENT_PORT);
	
	bind(confd, (struct sockaddr *)&localaddr, sizeof(localaddr));

	// 设置组播地址
	inet_pton(AF_INET, GROUP, &group.imr_multiaddr);
	// 将本地IP添加到组播组中
	inet_pton(AF_INET, "0.0.0.0", &group.imr_address);
	// 获取网卡编号
	group.imr_ifindex = if_nametoindex("eth0");

	// 设置权限
	setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &group, sizeof(group));

	while (1) {
		len = recvfrom(confd, buf, sizeof(buf), 0, NULL, 0);
		write(STDOUT_FILENO, buf, len);
	}
	close(confd);

	return 0;
}
```

### domain 本地套
IPC四种通信方式
1. pipe fifo	实现简单
2. mmap			进程间非血缘关系
3. signal		开销小
4. domain		稳定性好

```c
// server.c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>
#include <ctype.h>
#include <strings.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <stddef.h>

#include "wrap.h"

#define SERV_ADDR "serv.socket"

int main() {
	int lfd, cfd, len, size, i;
	struct sockaddr_un servaddr, cliaddr;
	char buf[BUFSIZ];
	
	lfd = Socket(AF_UNIX, SOCK_STREAM, 0);
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sun_family = AF_UNIX;
	strcpy(servaddr.sun_path, SERV_ADDR);
	
	/*
		offsetof(type, member)
		((int) &( (type*)0 )->member )
	*/
	len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);
	
	// 确保Bind之前不存在文件, Bind创建文件
	unlink(SERV_ADDR);
	// 参数3不是sizeof(servaddr)
	Bind(lfd, (struct sockaddr *)&servaddr, len);
	
	Listen(lfd, 20);

	printf("Accept ...\n");
	while (1) {
		len = sizeof(cliaddr);
		cfd = Accept(lfd, (struct sockaddr *)&cliaddr, (socklen_t *)&len);
		
		// 获取客户端socket文件名的长度
		len -= offsetof(struct sockaddr_un, sun_path);
		cliaddr.sun_path[len] = '\0';

		printf("client bind filename %s\n", cliaddr.sun_path);

		while ((size = read(cfd, buf, sizeof(buf))) > 0) {
			for (i = 0; i < size; ++i) {
				buf[i] = toupper(buf[i]);
			}
			write(cfd, buf, size);
		}
		close(cfd);
	}
	return 0;
}
```

```c
//client.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <stddef.h>
#include "wrap.h"

#define SERV_ADDR "serv.socket"
#define CLIE_ADDR "clie.socket"

int main () {
	int cfd, len;
	struct sockaddr_un servaddr, cliaddr;
	char buf[4096];

	cfd = Socket(AF_UNIX, SOCK_STREAM, 0);

	bzero(&cliaddr, sizeof(cliaddr));
	cliaddr.sun_family = AF_UNIX;
	strcpy(cliaddr.sun_path, CLIE_ADDR);

	// 计算地址结构的有效长度
	len = offsetof(struct sockaddr_un, sun_path) + strlen(cliaddr.sun_path);

	unlink(CLIE_ADDR);
	// 客户端也要bind, 不能依赖自动绑定
	Bind(cfd, (struct sockaddr *)&cliaddr, len);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sun_family = AF_UNIX;
	strcpy(servaddr.sun_path, SERV_ADDR);

	// 计算服务端地址结构的长度
	len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);

	Connect(cfd, (struct sockaddr *)&servaddr, len);

	while(fgets(buf, sizeof(buf), stdin) != NULL) {
		write(cfd, buf, strlen(buf));
		len = read(cfd, buf, sizeof(buf));
		write(STDOUT_FILENO, buf, len);
	}
	close(cfd);

	return 0;
}
```

## Shell

### 变量

```bash
# 命令起别名
alias ll='ls -al'
alias grep='grep --color=auto'
alias ls='ls --color=auto'

# 定义变量(默认在本地变量中), 添加到环境变量中
sanzo=666 # 定义
echo $sanzo # 打印
export sanzo # 添加到环境变量
env | grep sanzo
env | grep $sanzo
```

* 匹配多个任意字符
? 匹配一个任意字符
[若干字符] 匹配方括号中一个字符的一次出现

```bash
# 算术运算 10 + 20
var=10
echo $(($var+10))
echo $((var+10))
echo $[$var+10]
echo $[var+10]

echo &[2#10+8#12] # 2进制的10 + 8进制的12
```

- 转义字符

```bash
touch \$\ abc	# 创建$ abc文件
rm \$\ abc		# 删除$ abc文件

touch ./-abc  	# 创建-abc文件
touch -- -abc
rm ./-abc 	  	# 删除-abc文件
rm -- -abc

```

### 条件测试
test, []

```bash
# 满足返回0, 不满足返回1

[ -d dir ] 					# dir是目录为真
[ -f file ] 				# file是普通文件为真
[ -z STRING ]				# string长度是零为真
[ -n STRING ]				# string长度非零为真
[ STRING1 = STRING2 ]  		# 相同为真
[ STRING1 != STRING2 ] 		# 不同为真
[ ARG1 op ARG2 ]			# arg1, arg2为整数或取值为整数的变量, op有 -eq(等于), -ne(不等), -lt(小于), -le(小于等于), -gt(大于), -ge(大于等于)
test $var -le 100 			# 同上测试


echo $? # 输出上一次运行结果

VAR=
[ -n $VAR ] 	# 0
[ -n "$VAR" ]	# 1

-o	# 逻辑或
-a	# 逻辑与

[ -d dir -a $VAR = 10 ]	# dir是否为目录 而且 VAR等于10
变量取值最好放到""中
[ -d dir -a "$VAR" = 10 ]	# dir是否为目录 而且 VAR等于10
```

### 分支

- 判断文件类型
  ```bash
#! /bin/bash
  ```

if [ -d test ]; then
	echo "It is a dir"
elif [ -f test ]; then
	echo "It is a file"
else
	printf "Unknow\n"
fi

if :; then
	echo ": always true";
fi
  ```

- 读取用户输入

  ```bash
#! /bin/bash

echo "Is it morning? Please answer yes or no."

read YES_OR_NO

if [ "$YES_OR_NO" = "yes" ]; then
	echo "Good morning!"
elif [ "$YES_OR_NO" = no ]; then
	echo "Good afternoon!"
else
	echo "Sorry, $YES_OR_NO not recogized. Enter yes or no."
fi
  ```

- case语句
   ```bash
#! /bin/bash
   ```

echo "Is it morning? Please anser yes or no."

read YES_OR_NO

case "$YES_OR_NO" in
yes|Y|Yes|YES)
	echo "Good Morning!"
	;;
[nN]*)
	echo "Good Afternoon!"
	;;
*)
	echo "Sorry, $YES_OR_NO not recognized. Enter yes or no."
	return 1
	;;
esac

return 0
  ```

### 循环语句

- for/do/done

​```bash
#! /bin/bash

ls

for FILE in $(ls); do
	
	printf "$FILE "
	
	if [ -d "$FILE" ]; then
		echo "It is a dir"
	elif [ -f "$FILE" ]; then
		echo "It is a file"
	else
		echo "Other"
	fi
done
  ```

- while/do/done

```bash
#! /bin/bash

count=3

echo "Enter password"

read TRY

while [ "$TRY" != "secret" -a $count -gt 0 ]; do
	count=$[count-1]
	echo "Sorry, try again"
	read TRY
done
```

### 位置参数和特殊变量
$0、$1		# argv[0], argv[1]...
$#			# argc - 1
$@			# 参数列表, 可用在for循环的in后面
$*			# 参数列表, 同上
$?			# 上一条命令的exit status
$$			# 当前进程号

```bash
#! /bin/bash
shift # 参数列表左移

echo $0
echo $1
echo $2

echo $*
echo $@

echo $# 
```

### 输入输出

```bash
echo -e "hello\n" 	# 解析转义字符
echo -n "hello\n" 	# b不解析转义字符
```

```bash
ls -l | tee out		# tee保存到文件中一份

cmd > file 2>&1		# 输出重定向给file, 标准出错定向到标准输出

cmd < file1 > file2	# 从file中读取, 输出到file2中
cat < file1 > file2
wc -l < a.c > b

cmd < &fd			# 把文件描述符fd作为标准输入
cmd > &fd			# 把文件描述符fd作为标准输出
cmd < &- 			# 关闭标准输出
```

### 函数

```bash
#! /bin/bash

is_dir() 
{
	DIR_NAME=$1
	if [ ! -d $DIR_NAME ]; then
		return 1
	else
		return 0
	fi
}

for DIR in "$@"; do
	is_dir "$DIR"
	echo "$?"

	if is_dir "$DIR"; then :
	else 
		echo "$DIR doesn't exist. Creating it now..."
		mkdir $DIR > /dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "Cannot create dir $DIR"
			return 1
		fi
	fi
done
```
