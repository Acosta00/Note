# 基础知识

## 用户空间和内核空间

操作系统的核心是内核, 独立于普通的应用程序, 可以访问受保护的内存空间, 拥有访问底层硬件设备的所有权限. 为了保证用户进程不能直接操作内核, 保证内核安全, 操作系统将虚拟空间分为两部分, 内核空间和用户空间.
其中最高的1G字节(虚拟地址: 0xC0000000 到 0xFFFFFFFF)为内核区域, 低位的3G(虚拟地址: 0x00000000 到 0xBFFFFFFF)为用户空间.

## 进程切换

内核挂起CPU上运行的进程, 恢复以前挂起的某个进程的执行.
从一个进程的运行到另一个进程的运行, 经历以下变化

1. 保存处理机上下文, 包括程序计数器和其他寄存器
2. 更新PCB信息
3. 把进程的PCB移入相应的队列, 就绪 阻塞等队列
4. 选择另一个进程执行, 更新PCB
5. 更新内存管理的数据结构
6. 恢复处理机上下文

## IO

同步: 调用一个功能, 功能没有结束, 一直等待结果
异步: 调用一个功能, 不需要知道功能结果, 有结果通过回调通知
阻塞: 调用函数, 杉树没有接受完数据或没有结果之前不返回
非阻塞: 调用函数, 函数立即返回, 通过select通知调用者
同步IO和异步IO的区别: 数据拷贝时进程是否阻塞
阻塞IO和非阻塞IO的区别: 应用程序的调用是否立即返回

# gcc编译

```bash
# 预处理器 cpp, 展开通文件, 宏替换, 去掉注释
gcc -E hello.c -o hello.i
# 编译器 gcc, c文件 -> 汇编文件
gcc -S hello.i -o hello.s
# 汇编器 as, 汇编文件 -> 二进制文件
gcc -c hello.s -o hello.o
# 链接器 ld, 将函数库中的代码组合到目标文件中
gcc hello.o -o hello
```

## 静态库

将.o文件打包为静态库.a, 程序运行只需要有头文件和静态库即可

在生成可执行文件时, 将程序所用到的.o文件, 从静态库中打包到可执行文件

```bash
# 命名
lib + 名字 + .a

# 生成二进制文件
## -I 指定头文件目录
gcc *.c -c -I include

# 打包为静态库
## 将.o文件打包为test静态库
ar rcs libtest.a *.o

# 使用静态库
## 使用lib下的静态库test将main.c编译为可执行文件app
gcc main.c lib/libtest.a -o app -I include
gcc main.c -I include -L lib -l test -o app

# nm查看查看文件中符号
nm app
```

### 动态库

```bash
# 生成与位置无关的.o
## 当程序运行之后, 在共享库中加载动态库. 相对地址
gcc -fPIC -c *.c -I include

# 打包动态库
gcc -shared -o libtest.so *.o -I include

# 使用动态库
## 首先需要配置动态库地址
### 1.系统的动态库/lib, 不推荐
### 2.暂时将库导入终端的配置文件LD_LIBRARY_PATH
export LD_LIBRARY_PATH=./lib
### 3.永久配置
vim .bashrc
export LD_LIBRARY_PATH=home/user/lib
### 4.修改系统动态库
sudo vim /etc/ld.so.conf
/home/user/lib
sudo ldconfig -v

# 查看可执行文件依赖的动态库
ldd app
```

### Makefile

目标: 依赖
	命令

- 普通版

    ```bash
    app: main.o sum.o sub.o
         gcc main.o sum.o sub.o -o app
    
    main.o: main.c
    	gcc -c main.c
    
    sum.o: sum.c
    	gcc -c sum.c
    
    sub.o: sub.c
    	gcc -c sub.c
    ```

    

- 自动变量替换版

    ```bash
    $<: 规则中的第一个依赖
    $@: 规则中的目标
    $^: 规则中的所有依赖
    obj = main.o sum.o sub.o
    target = app
    # makefile系统变量
    CC = gcc
    
    $(target):$(obj)
    $(CC) $(obj) -o $(target)
    
    %.o: %.c
    $(CC) -c $< -o $@
    ```

- makefile函数

  ```bash
  target = app
  # 得到所有.c文件
  src = $(wildcard ./*.c)
  # 将.c替换为.o
  obj = $(patsubst ./%.c, ./%.o, $(src))
  CC = gcc
  
  $(target): $(obj)
  	$(CC) $(obj) -o $(target)
  
  %.o: %.c
  	$(CC) -c $< -o $@
  	
  # 声明伪目标
  .PHONY:clean
  clean:
  	rm $(obj) $(target)
  ```
  静态模型: $(objects): %.o:%.c
  ```
  objects = foo.o bar.o
  all: $(objects)
  $(objects): %.o: %.c
  	$(CC) -c $(CFLAGS) &< -o $@
  目标从$(objects)中获取， "%.o"表示以".o"结尾的目标, 即foo.o bar.o, 依赖模式就是把"%.o"中的"%"拿来加上".c"
  ```



## gdb调试

| list           | l    | 显示多行源代码                                               |
| -------------- | ---- | ------------------------------------------------------------ |
| break          | b    | 设置断点,程序运行到断点的位置会停下来                        |
| info           | i    | 描述程序的状态                                               |
| run            | r    | 开始运行程序                                                 |
| display        | disp | 跟踪查看某个变量,每次停下来都显示它的值                      |
| step           | s    | 执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句 |
| next           | n    | 执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句) |
| print          | p    | 打印内部变量值                                               |
| continue       | c    | 继续程序的运行,直到遇到下一个断点                            |
| set var name=v |      | 设置变量的值                                                 |
| start          | st   | 开始执行程序,在main函数的第一条语句前面停下来                |
| file           |      | 装入需要调试的程序                                           |
| kill           | k    | 终止正在调试的程序                                           |
| watch          |      | 监视变量值的变化                                             |
| backtrace      | bt   | 产看函数调用信息(堆栈)                                       |
| frame          | f    | 查看栈帧                                                     |
| quit           | q    | 退出GDB环境                                                  |



# 文件操作

### open

返回值

1. -1 打开失败

2. \> 0 文件描述符

```bash
# 创建文件
int fd = open("filename", O_RDWR | O_CREAT, 0777);

# 判断文件是否存在
int fd = open("filename", O_RDWR | O_CREAT | O_EXCL, 0777);

# 文件截断
int fd = open("filename", O_RDWR | O_TRUNC);

# 关闭文件
int ret = close(fd);
```

### read, write

返回值

1. -1 读取失败
2. 0 读取完毕
3. \> 0 读取的字节数

```bash
char *buf[10];
int main() {
    int fd = open("hello", O_RDONLY);
    if (fd == -1) {
        perror("open");
    }
    
    int fd1 = open("newhello", O_WRONLY | O_CREAT, 0664);
    if (fd1 == -1) {
        perror("open1");
    }
    int len;
    // 循环读一个文件, 写到另一个文件
    while ((len = read(fd, buf, 10)) != 0) {
        if (len == -1) {
            perror("read");
            exit(1);
        }
        write(fd1, buf, len);
        printf("write bytes %d\n", len);
    }
    close(fd);
    close(fd1);
}
```





### lseek

```c
int main() {
    int fd = open("aa", O_RDWR);
    if (fd == -1) {
        perror("open file");
        exit(1);
    }
    // 文件大小
    int ret = lseek(fd, 0, SEEK_END);
    printf("file length = %d\n", ret);

    // 文件扩展
    ret = lseek(fd, 2000, SEEK_END);
    printf("file lingth = %d\n", ret);
    write(fd, "a", 1);
    close(fd);
}
```

### stat

```c
# 实现ls命令
int main(int argc, char* argv[]) {
    if (argc < 2) { 
        printf("./a.out filename\n");
        exit(1);
    }
    struct stat st;
    int ret = stat(argv[1], &st);
    if (ret == -1) {
        perror("stat");
        exit(1);
    }
    // 存放文件类型和访问权限
    char perms[11] = {0};
    // 判断文件类型
    switch (st.st_mode & S_IFMT) {
        case S_IFLNK:
            perms[0] = 'l';
            break;
        case S_IFDIR:
            perms[0] = 'd';
            break;
        case S_IFREG:
            perms[0] = '-';
            break;
        case S_IFBLK:
            perms[0] = 'b';
            break;
        case S_IFCHR:
            perms[0] = 'c';
            break;
        case S_IFSOCK:
            perms[0] = 's';
            break;
        case S_IFIFO:
            perms[0] = 'p';
            break;
        default:
            perms[0] = '?';
            break;
    }

    // 判断文件访问权限
    // owner
    perms[1] = (st.st_mode & S_IRUSR) ? 'r' : '-';
    perms[2] = (st.st_mode & S_IWUSR) ? 'w' : '-';
    perms[3] = (st.st_mode & S_IXUSR) ? 'x' : '-';
    // group
    perms[4] = (st.st_mode & S_IRGRP) ? 'r' : '-';
    perms[5] = (st.st_mode & S_IWGRP) ? 'w' : '-';
    perms[6] = (st.st_mode & S_IXGRP) ? 'x' : '-';
    // others
    perms[7] = (st.st_mode & S_IROTH) ? 'r' : '-';
    perms[8] = (st.st_mode & S_IWOTH) ? 'w' : '-';
    perms[9] = (st.st_mode & S_IXOTH) ? 'x' : '-';
    // 硬链接数
    int linkNum = st.st_nlink;
    // 所有者
    char *fileOwner = getpwuid(st.st_uid)->pw_name;
    // 所属组
    char *fileGrp = getgrgid(st.st_gid)->gr_name;
    // 大小
    int fileSize = (int)st.st_size;
    // 修改时间
    char *time = ctime(&st.st_mtime);
    char mtime[512] = {0};
    strncpy(mtime, time, strlen(time) - 1);
    char buf[1024];
    sprintf(buf, "%s %d %s %s %d %s %s", perms, linkNum, fileOwner, fileGrp, fileSize, mtime, argv[1]);
    printf("%s\n", buf);
}
```



### access

```c
# 判断文件是否具有某种权限
int ret = access(argv[1], W_OK | R_OK | X_OK | F_OK);
F_OK 判断是否存在
ret = 0, 具有这些权限
ret = -1, 有些权限被禁止
```



### chmod

```c
# 修改文件权限
int main(int argc, char* argv[]) {
    if (argc < 3) {
        printf("./a.out filename 0644\n");
        exit(1);
    }

    int val = strtol(argv[2], NULL, 8); // 字符串转数字
    printf("%s %d\n", argv[2], val);
    int ret = chmod(argv[1], val);
    if (ret == -1) {
        perror("chmod");
        exit(1);
    }
}
```

### chown



```c
# 修改用户和组id
int main(int argc, char *argv[]) {
    if (argc < 4) {
        printf("./a.out filename uid gid\n");
        exit(1);
    }
    int uid = strtol(argv[2], NULL, 10);
    int gid = strtol(argv[3], NULL, 10);
    printf("uid = %d\n gid = %d\n", uid, gid);
    int ret = chown(argv[1], uid, gid);
    if (ret == -1) {
        perror("chown");
        exit(1);
    }
}
```



### truncate

```c
# 文件截断
int main(int argc ,char *argv[]) {
    if (argc < 3) {
        printf("./a.out filename size\n");
        exit(1);
    }
    int len = strtol(argv[2], NULL, 10);
    int ret = truncate(argv[1], len);
    if (ret == -1) {
        perror("truncate");
        exit(1);
    }
}
```



### readlink

```c
# 读取链接文件
int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("./a.out softlink\n");
        exit(1);
    }
    
    char buf[1024];
    int ret = readlink(argv[1], buf, sizeof(buf));
    if (ret == -1) {
        perror("readlink");
        exit(1);
    }
    buf[ret] = 0;
    printf("buf = %s\n", buf);
}
```



### unlink

```c
# 删除文件
int main(int argc, char *argv[]) {
    int fd = open("tmpfile", O_CREAT | O_RDWR, 0644);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // 删除临时文件
    int ret = unlink("tmpfile");
    
    // 写文件
    write(fd, "hello\n", 6);
    lseek(fd, 0, SEEK_SET);
    char buf[1024] = {0};
    // 读文件
    int len = read(fd, buf, sizeof(buf));
    // 输出到屏幕
    write(1, buf, len);

    close(fd);
    return 0;
}
```

### rename

```c
int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("./rename oldname newname\n");
        exit(1);
    }
    int ret = rename(argv[1], argv[2]);
    if (ret == -1) {
        perror("rename");
        exit(1);
    }
}
```



### chdir, getcwd

```c
int main(int argc, char *argv[]) {
	if (argc < 2) {
		printf("./chdir path\n");
		exit(1);
	}
	int ret = chdir(argv[1]);
	if (ret == -1) {
		perror("chdir");
		exit(1);
	}
	int fd = open("chdir.txt", O_CREAT | O_RDWR, 0777);
	if (fd == -1) {
		perror("open");
		exit(1);
	}
	close(fd);
	char buf[256];
	getcwd(buf, sizeof(buf));
	printf("current dir: %s\n", buf);
	return 0;
}
```

### opendir, readdir, closedir

```c
# 递归读取文件数目
int getFileNum(char *root) {
    // open dir
    DIR *dir = NULL;
    dir = opendir(root);
    if (dir == NULL) {
        perror("opendir");
        exit(1);
    }
    // 遍历当前目录
    int cnt = 0;
    char buf[1024] = {0};
    struct dirent *ptr = NULL;
    while((ptr = readdir(dir)) != NULL) {
        if(strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0)
            continue;
        if (ptr->d_type == DT_DIR) {
            sprintf(buf, "%s/%s", root, ptr->d_name);
            cnt += getFileNum(buf);
        }else if (ptr->d_type == DT_REG) {
            cnt++;
        }
    }
    // 关闭目录
    closedir(dir);
    return cnt;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("./fileNum dir\n");
        exit(1);
    }
    int cnt = 0;
    cnt = getFileNum(argv[1]);
    printf("%s %d\n", argv[1], cnt);
    return 0;
}
```



### dup, dup2

```c
# dup
int main() {
    int fd = open("a.txt", O_RDWR);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    printf("file fd = %d\n", fd);
    // 返回最小的文件描述符
    int ret = dup(fd);
    if (ret == -1) {
        perror("dup");
        exit(1);
    }
    printf("dup fd = %d\n", ret);
    char *buf = "hello world\n";
    char *buf1 = "hi world\n";
    // fd, ret指向同一个文件, 位置同步
    write(fd, buf, strlen(buf));
    write(ret, buf1, strlen(buf1));
    close(fd);
    return 0;
}

# dup2
int main() {
    int fd = open("a.txt", O_RDWR);
    if (fd == -1) {
        perror("a.txt open");
        exit(1);
    }
    int fd1 = open("b.txt", O_RDWR);
    if (fd1 == -1) {
        perror("b.txt open");
        exit(1);
    }
    printf("a.txt fd = %d\n", fd);
    printf("b.txt fd = %d\n", fd1);
    // 把fd复制到fd1           
    int ret = dup2(fd, fd1);
    if (ret == -1) {
        perror("dup2");
        exit(1);
    }
    printf("current fd1 = %d\n", fd1);
    char *buf = "dup2222222222222222222222222\n";
    write(fd, buf, strlen(buf));
    write(fd1, "hello world\n", 12);
    close(fd);
    close(fd1);

    return 0;
}
```



### fcntl

```c
int main() {
    int fd;
    int flag;
    char *buf = "桃花坞里桃花庵, 桃花庵下桃花仙";
    char *buf1 = "桃花仙人种桃树, 又摘桃花买酒钱";
    // open file
    fd = open("test.txt", O_WRONLY);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    
    if (write(fd, buf, strlen(buf)) == -1) {
        perror("write");
        exit(1);
    }
    
    flag = fcntl(fd, F_GETFL, 0);
    if (flag == -1) {
        perror("fcntl");
        exit(1);
    }
    // 添加文件状态: 追加
    flag |= O_APPEND;
    if (fcntl(fd, F_SETFL, flag) == -1) {
        perror("fcntl -- append write");
        exit(1);
    }

    if (write(fd, buf1, strlen(buf1)) == -1) {
        perror("write again");
        exit(1); 
    }
    close(fd);
    return 0;
}
```



# 系统编程
## 进程

### environ

```c
int main() {
    int i;
    for (int i = 0; environ[i]; ++i) {
        printf("%s\n", environ[i]);
    }
    return 0;
}
```

### getenv, setenv, unsetenv

```c
int main() {
    char *val;
    const char *name = "AAA";
    int ret;
    // getenv
    val = getenv(name);
    printf("name = %s, val = %s\n", name, val);

    // setenv
    ret = setenv(name, "hello world", 1);
    if (ret == -1) {
        perror("setenv");
        exit(1);
    }

    val = getenv(name);
    printf("name = %s, val = %s\n", name, val);

    // unsetenv
    ret = unsetenv(name);
    if (ret == -1) {
        perror("AAA unsetenv");
        exit(1);
    }
    printf("name = %s, unsetenv = %d\n", name, ret);

    ret = unsetenv("BBB");
    if (ret == -1) {
        perror("BBB unsetenv");
        exit(1);
    }
    printf("name = %s, unsetenv = %d\n", "BBB", ret);

    return 0;
}
```

### fork

- 父进程返回子进程的pid, 子进程返回0

- 读时共享, 写时复制

- 父子进程共享: 
  - 文件描述符
  - mmap建立的映射区
- 父子进程顺序由内核调度算法决定

```c
# 创建单个进程
int main() {
    printf("this is fork.c\n");

    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if(pid > 0) {
        printf("I am father, pid = %d, ppid = %d\n", getpid(), getppid());
        sleep(1);
    }else {
        printf("I am child, pid = %d, ppid = %d\n", getpid(), getppid());
    }
    printf("bye\n");

    return 0;
}

# 创建多个进程
int main() {
    printf("this is mul_fork.c\n");
    pid_t pid;
    int i;
    for (i = 0; i < 5; ++i) {
        pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(1);
        }else if (pid == 0) {
            break;
        }else {
            sleep(1);
        }
    }
    if (i < 5) {
        printf("I am %d child, pid = %u, ppid = %u\n", i, getpid(), getppid());
    }
    
    return 0;
}
```



### exec

- execlp, 借助环境变量加载进程
- execl, 通过路径+程序名加载进程

```c
int main() {
    pid_t pid;
    pid = fork();

    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid > 0) {
        sleep(2); 
        printf("I am father\n");
    }else {
        // execlp("ls", "ls", "-l", "-a", NULL);
        // execl("/bin/ls", "ls", "-l", "-a", NULL);
        char *argv[] = {"ls", "-l", "-a", NULL};
        execv("/bin/ls", argv);
    }
    return 0;
}

# 利用dup2实现exec输出到文件中
int main() {
    int fd;
    fd = open("ps.log", O_CREAT | O_WRONLY | O_TRUNC, 06444);
    if (fd < 0) {
        perror("open");
        exit(1);
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid > 0) {
        sleep(1);
        printf("I am father\n");
    }else {
        dup2(fd, 1);
        execlp("ps", "ps", "-aux", NULL);
    }

    return 0;
}
```



### 孤儿, 僵尸进程

```c
// orphan.c
int main() {
    pid_t pid;
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if(pid > 0) {
        sleep(1);    
        printf("I am father, pid = %d, ppid = %d\n", getpid(), getppid());
    }else {
        printf("I am child,  pid = %d, ppid = %d\n", getpid(), getppid());
        sleep(3);
        printf("I am child,  pid = %d, ppid = %d\n", getpid(), getppid());
    }
    return 0;
}

// zoom.c
int main() {
    pid_t pid;
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if(pid == 0) {
        printf("I am child, pid = %d, ppid = %d\n", getpid(), getppid());
        sleep(4);    
        printf("I am child, i gona dead\n");
    }else {
        while (1) {
            sleep(1);
            printf("I am father, pid = %d, ppid = %d\n", getpid(), getppid());
        }
    }
    return 0;
}
```

### wait

- 阻塞等待子进程退出
- 回收子进程
- 获取子进程状态

多个子进程, 只能回收一个

```c
// 正常退出
int main() {
    pid_t pid, wpid;
    int status;

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid > 0) {
        wpid = wait(&status);
        printf("wpid = %d\n", wpid);
        if (wpid == -1) {
            perror("wait");
            exit(1);
        }
        if (WIFEXITED(status)) { // 正常退出
            // 获取退出值
            printf("child exit with %d\n", WEXITSTATUS(status));
        }

        if (WIFSIGNALED(status)) { // 非正常退出
            // 获取信号值
            printf("child killed by %d\n", WTERMSIG(status));
        }
        while (1) {
            sleep(1);
            printf("I am father, pid = %d\n", getpid());
        }
    }else {
        printf("I am child, pid = %d, ppid = %d\n", getpid(), getppid());
        sleep(30);
        exit(1);
    }

    return 0;
}
```



```c
// 异常退出
int main() {
    pid_t pid, wpid;
    int status;

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid > 0) {
        wpid = wait(&status);
        printf("wpid = %d\n", wpid);
        if (wpid == -1) {
            perror("wait");
            exit(1);
        }
        if (WIFEXITED(status)) { // 正常退出
            // 获取退出值
            printf("child exit with %d\n", WEXITSTATUS(status));
        }

        if (WIFSIGNALED(status)) { // 非正常退出
            // 获取信号值
            printf("child killed by %d\n", WTERMSIG(status));
        }
        while (1) {
            sleep(1);
            printf("I am father, pid = %d\n", getpid());
        }
    }else {
        printf("I am child, pid = %d, ppid = %d\n", getpid(), getppid());
        // int a = 10 / 0;
        
        // char *s = "asdada";
        // s[1] = 'a';
        
        execl("seg", "seg", NULL);

        sleep(3);
        exit(1);
    }

    return 0;
}
```



### waitpid

waitpid(pid_t pid, int *status, int option);

pid > 0 回收制定pid的子进程

pid = -1 回收任意子进程

pid = 0 回收当前调用waitpid一个组的所有子进程

pid < -1 回收制定进程组的任意子进程

```c
// loop_wait.c
int main() { 
    pid_t pid, wpid;
    int i;
    for (i = 0; i < 3; ++i) {
        pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(1);
        }else if(pid == 0) {
            break;
        }
    }
    if (i < 3) {
        sleep(i);
        printf("I am %d child, pid = %d, ppid = %d\n", i, getpid(), getppid());
    }else{
        sleep(i);
        printf("I am father, pid = %d\n", getpid());
        // 阻塞回收所有进程
        //while ((wpid = waitpid(-1, NULL, 0)) > 0) { // 等价于 wait(NULL)
        //    printf("child pid = %d exit\n", wpid);
        //}
        
        // 轮训回收所有的子进程
        int cnt = 0;
        do {
            wpid = waitpid(-1, NULL, WNOHANG);
            if (wpid > 0) {
                printf("child pid = %d exit\n", wpid);
                cnt++;
            }
            // 参数为WNOHANG且子进程没有退出, 返回0
            sleep(1);
        }while (cnt != 3);
    }

    return 0;
}
```

## IPC方法

### 管道

```c
// pipe.c 单向通信, 依赖血缘
int main() {
    int fd[2];// 0读, 1写
    int ret;
    pid_t pid;

    ret = pipe(fd);
    if (ret == -1) {
        perror("pipe");
        exit(1);
    }
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid == 0) { // write
        close(fd[0]);
        char *buf = "hello world\n";
        write(fd[1], buf, strlen(buf));
    }else { // read
        close(fd[1]);
        char buf[1024];
        for (int i = 0; i < 1024; ++i) {
            buf[i] = 'x';
        }
        ret = read(fd[0], buf, sizeof(buf));
        write(STDOUT_FILENO, buf, ret);
        buf[ret] = 0;
        printf("read: %s", buf);
    }

    return 0;
}
```

```c
// fifo.c 单向通信, 不依赖血缘
int main() {
    if (mkfifo("pp", 0666) < 0 && errno != EEXIST) {
        perror("mkfifo");
        exit(1);
    }
    pid_t pid;
    pid = fork();

    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid == 0) { // 读
        int fd = open("pp", O_RDONLY);
        char buf[1024];
        int len = read(fd, buf, sizeof(buf));
        write(STDOUT_FILENO, buf, len);
        close(fd);
    }else { // 写
        int fd = open("pp", O_WRONLY);
        char *buf = "hello world\n";
        write(fd, buf, strlen(buf));
        close(fd);
    }
    return 0;
}
```

### 共享内存

- MAP_SHARED时创建映射区的权限 $\le$ 打开文件的权限

- 映射的创建隐含对文件的读操作

- offset, 映射文件的偏移必须是4k的倍数, mmu内存映射最小为4k
- 映射区的释放与文件关闭无关
- 映射大小不能为0

```c
/* mmap.c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
*/
    
int main() {
    int fd = open("test.txt", O_RDWR | O_CREAT, 0644);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    int ret = truncate("test.txt", 4);
    if (ret == -1) {
        perror("truncate");
        exit(1);
    }
    char *p = NULL;
    p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }
    strcpy(p, "hel\n");
    
    ret = munmap(p, 4);
    if (ret == -1) {
        perror("munmap");
        exit(1);
    }
    close(fd);

    return 0;
}
```



```c
// 进程通信 - 匿名映射1
int var = 100;
int main() {
    int *p = NULL;
    pid_t pid;
    p = (int*) mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0); // MAP_ANON匿名映射, 只在linux可以使用
    if (p == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid == 0) {
        *p = 1000;
        var = 200;
        printf("child, *p = %d, var = %d\n", *p, var);
        exit(1);
    }else {
        sleep(1);
        printf("father, *p = %d, var = %d\n", *p, var);
        wait(NULL);
        int ret = munmap(p, 4);
        if (ret == -1) {
            perror("munmap");
            exit(1);
        }
    }
    return 0;
}
```

```c
// 进程通信 - 匿名映射2
int var = 100;
int main() {
    int *p = NULL;
    pid_t pid;
    int fd = open("/dev/zero", O_RDWR);
    p = (int*) mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); // 使用字符文件
    if (p == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(1);
    }else if (pid == 0) {
        *p = 1000;
        var = 200;
        printf("child, *p = %d, var = %d\n", *p, var);
        exit(1);
    }else {
        sleep(1);
        printf("father, *p = %d, var = %d\n", *p, var);
        wait(NULL);
        int ret = munmap(p, 4);
        if (ret == -1) {
            perror("munmap");
            exit(1);
        }
    }

    return 0;
}
```

```c
// 非血缘关系的进程通信
// mmap_read.c
struct STU{
    int id;
    char name[20];
    char sex;
};

void sys_err(char *str) {
    perror(str);
    exit(1);
}

int main(int argc, char *argv[]) {
    int fd;
    struct STU student;
    struct STU *p;
    if (argc < 2) {
        printf("./mmap_read file_share_path");
        exit(1);
    }
    fd = open(argv[1], O_RDONLY);
    if (fd == -1) {
        sys_err("open");
    }
    p = mmap(NULL, sizeof(student), PROT_READ, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) {
        sys_err("mmap");
    }
    close(fd);

    while (1) {
        printf("id = %d, name = %s, sex = %c\n", p->id, p->name, p->sex);
        sleep(2);
    }
    munmap(p, sizeof(student));
    return 0;
}
```

```c
// mmap.write
struct STU{
    int id;
    char name[20];
    char sex;
};

void sys_err(char *str) {
    perror(str);
    exit(1);
}

int main(int argc, char *argv[]) {
    int fd;
    struct STU student = {10, "sanzo", 'M'};
    struct STU *p;

    if (argc < 2) {
        printf("./a.out file_shared_path\n");
        exit(1);
    }
    fd = open(argv[1], O_RDWR|O_CREAT, 0644);
    ftruncate(fd, sizeof(student));
    p = mmap(NULL, sizeof(student), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) {
        sys_err("mmap");
    }
    close(fd);
    while (1) {
        memcpy(p, &student, sizeof(student));
        student.id++;
        sleep(1);
    }
    munmap(p, sizeof(student));
    return 0;
}
```



## 信号

### alarm

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    alarm(1);
    for (int i = 0; ; ++i) {
        printf("%d\n", i);
    }
    return 0;
}
```

### setitimer

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

unsigned int my_alarm(unsigned int sec) {
    struct itimerval it, oldit;
    it.it_value.tv_sec = sec;
    it.it_value.tv_usec = 0;
    it.it_interval.tv_sec = 0;
    it.it_interval.tv_usec = 0;

    int ret = setitimer(ITIMER_REAL, &it, &oldit);
    if (ret == -1) {
        perror("setitimer");
        exit(1);
    } 
    return oldit.it_value.tv_sec;
}

int main() {
    my_alarm(1);
    for (int i = 0; ; ++i) {
        printf("%d\n", i);
    }
    return 0;
}
```

### signal

```c
// signal.c
#include <stdio.h>
#include <sys/time.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

void myfunc(int signo) {
    printf("hello sanzo!\n");
}

int main() {
    struct itimerval it, oldit;
    signal(SIGALRM, myfunc); // 注册SIGALRM信号的捕捉处理函数
    it.it_value.tv_sec = 5;
    it.it_value.tv_usec = 0;

    it.it_interval.tv_sec = 3;
    it.it_interval.tv_usec = 0;

    int ret = setitimer(ITIMER_REAL, &it, &oldit);
    if (ret == -1) {
        perror("setitimer error");
        exit(1);
    }

    while (1);
    return 0;
}
```



### 信号集

自定义信号集影响阻塞信号集, 阻塞信号集影响未决信号集

```c
// print_sigpending.c
include <stdio.h>
#include <signal.h>
#include <unistd.h>
void print_ped(sigset_t *ped) {
    for (int i = 0; i < 32; ++i) {
        if (sigismember(ped, i) == 1) { // 判断信号是否在集合中
            putchar('1');
        }else {
            putchar('0');
        }
    }
    printf("\n");
}
int main() {
    sigset_t myset, oldset, ped;
    sigemptyset(&myset); // 置空信号集
    sigaddset(&myset, SIGQUIT); // 添加对应信号置1
    sigaddset(&myset, SIGINT);
    sigaddset(&myset, SIGTSTP);

    sigprocmask(SIG_BLOCK, &myset, &oldset); // 修改阻塞信号集
    
    while (1) {
        sigpending(&ped); // 获取未决信号集
        print_ped(&ped);
        sleep(1);
    } 
    return 0;
}
```



### sigaction

信号捕捉期间阻塞的信号产生多次只记录一次.

内核捕捉信号的过程:

1. 在用户空间执行代码
2. 接收到信号进入内核空间
3. 内核空间调用捕捉函数
4. 在用户空间执行捕捉函数
5. 捕捉函数执行完毕, 执行特殊的系统调用sigreturn回到调用函数的内核空间
6. 到用户空间接着执行代码

```c
// sigaction.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void docatch(int signo) {
    printf("%d signal is catch\n", signo);
    sleep(5);
    printf("catch is done\n");
}

int main() {
    struct sigaction act;
    act.sa_handler = docatch;
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGQUIT); // 设置捕捉期间的屏蔽
    act.sa_flags = 0; // 默认属性, 信号捕捉执行期间, 自动屏蔽本信号

    int ret = sigaction(SIGINT, &act, NULL);
    if (ret < 0) {
        perror("sigaction error");
        exit(1);
    }
    while (1);
    return 0;
}
```



### 时序竞态

pause可以造成进程主动挂起, 等待信号唤醒, 当信号捕捉而且捕捉函数返回pause会返回-1,同时errno设置为EINTR

```c
/* 	
 	pause.c
	alarm + pause 实现sleep, 存在时序竞态的问题
	如果程序在alarm之后失去cpu, alarm的计时不会停止, 当进程重新获取cpu之后,
	进程首先会处理到时间触发的alarm信号, 之后的pause就不能被唤醒
*/
#include <stdio.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

void docatch(int signo) {
    return;
}

unsigned int mysleep(unsigned int seconds) {
    struct sigaction act, oldact;
    act.sa_handler = docatch;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    sigaction(SIGALRM, &act, &oldact);
    alarm(seconds);
    int ret = pause(); // 主动挂起 等待信号
    if (ret == -1 && errno == EINTR) {
        printf("pause sucess\n");
    }
    
    ret = alarm(0);
    sigaction(SIGALRM, &oldact, NULL); // 恢复SIGALRM的默认处理方式

    return ret;
}
int main() {
    while (1) {
        mysleep(2);
        printf("----------------\n");
    }
    return 0;
}
```

```c
/*
	sigsuspend.c
	为了解决时序竞态问题, 可以在alarm之后对SIGALRM进行屏蔽, 然后使用原子操作的sigsuspend, 在pause的同时使用临时的阻塞信号集, 取消之前的屏蔽.
*/
#include <stdio.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

void docatch(int signo) {
    return;
}

unsigned int mysleep(unsigned int seconds) {
    sigset_t newmask, oldmask, suspmask;
    struct sigaction act, oldact;
    unsigned int unslept;

    // 为SIGALRM设置捕捉函数
    act.sa_handler = docatch;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(SIGALRM, &act, &oldact);

    // 设置阻塞信号集, 阻塞SIGALRM
    sigemptyset(&newmask);
    sigaddset(&newmask, SIGALRM);
    sigprocmask(SIG_BLOCK, &newmask, &oldmask);

    // 定时
    alarm(seconds);

    // 调用sigsuspend, 使用临时有效的阻塞信号集
    // 在临时阻塞集合中解除SIGALRM信号的阻塞
    // sigsuspend完成之后, 恢复之前的阻塞信号集
    suspmask = oldmask;
    sigdelset(&suspmask, SIGALRM);
    sigsuspend(&suspmask); // 原子操作

    unslept = alarm(0);
    // 恢复SIGALRM原有的处理动作
    sigaction(SIGALRM, &oldact, NULL);

    // 解除对SIGALRM的阻塞, 恢复之前的阻塞信号集
    sigprocmask(SIG_SETMASK, &oldmask, NULL);
    return unslept;
}
int main() {
    while (1) {
        mysleep(2);
        printf("----------------\n");
    }
    return 0;
}
```

### 全局变量的异步IO

```c
/*
	sync_process.c
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

int n = 0, flag = 0;

void sys_err(char *str) {
    perror(str);
    exit(1);
}

void do_sigchild(int signo) {
    printf("I am child %d\t%d\n", getpid(), n);
    n += 2;
    flag = 1;
//    sleep(1);
}

void do_sigparent(int signo) {
    printf("I am parent %d\t%d\n", getpid(), n);
    n += 2;
    flag = 1;
//    sleep(1);
}

int main() {
    pid_t pid;
    struct sigaction act;
    if ((pid = fork()) < 0) {
        sys_err("fork");
    }else if (pid > 0) { 
        n = 1;
        sleep(1);
        act.sa_handler = do_sigparent;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        sigaction(SIGUSR2, &act, NULL);
        do_sigparent(0);
        while (1) {
            if (flag == 1) {
                kill(pid, SIGUSR1);
                flag = 0; // flag的值前后可能存在时序竞态错误
            }
        }
    }else if(pid == 0){
        n = 2;
        act.sa_handler = do_sigchild;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        sigaction(SIGUSR1, &act, NULL);
        while (1) {
            if (flag == 1) {
                kill(getppid(), SIGUSR2);
                flag = 0; 
            }
        }
    }
    return 0;
}
```

```c
/*
	sync_process1.c
	不使用flag, 每次捕捉函数之后, 发送kill
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

int n = 0;
int ppid, cpid;
void sys_err(char *str) {
    perror(str);
    exit(1);
}

void do_sigchild(int signo) {
    printf("I am child %d\t%d\n", getpid(), n);
    n += 2;
    kill(ppid, SIGUSR2);
}

void do_sigparent(int signo) {
    printf("I am parent %d\t%d\n", getpid(), n);
    n += 2;
    kill(cpid, SIGUSR1);
}

int main() {
    pid_t pid;
    struct sigaction act;
    if ((pid = fork()) < 0) {
        sys_err("fork");
    }else if (pid > 0) { 
        ppid = getpid();
        cpid = pid;
        n = 1;
        sleep(1);
        act.sa_handler = do_sigparent;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        sigaction(SIGUSR2, &act, NULL);
        do_sigparent(0);
        while (1);
    }else if(pid == 0){
        cpid = getpid();
        ppid = getppid();
        n = 2;
        act.sa_handler = do_sigchild;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        sigaction(SIGUSR1, &act, NULL);
        while (1);
    }
    return 0;
}
```

### 守护进程
1. 创建子进程 fork
2. 子进程创建会话 setsid
3. 改变进程的工作目录 chdir
4. 指定文件演码 umask
5. 将0/1/2重定向 /dev/null dup2
6. 守护进程主逻辑
7. 退出


## 线程

LWP: light weight process 轻量级的进程, 本质是进程
进程: 独立地址空间, 拥有PCB
线程: 共享地址空间, 拥有PCB
Linux下， 线程是最小的执行单位，进程是最小的资源分配单位可以看作只有一个线程的进程

线程提高程序占有cpu的时间

线程共享的资源：
- 文件描述符表
- 每种信号的处理方式
- 当前工作目录
- 用户ID和组ID
- 内存地址空间(.text/.data/.bss/heap/共享库)

线程非共享资源
- 线程ID
- 处理器现场和栈指针(内核栈)
- 独立的栈空间(用户空间栈)
- errno变量
- 信号屏蔽字
- 调度优先级

优点:
- 提高程序并发性
- 开销小
- 数据通信、共享数据方便

缺点:
- 使用库函数不稳定
- 调试困难, 编写困难, gdb不支持
- 对信号支持不好

### 创建线程

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void *thrd_func() {
	printf("In thread: pthread id = %lu, pid = %d\n", pthread_self(), getpid());
	return NULL;
}

int main() {

	pthread_t tid;
	int ret;

	printf("In main1: pthread id = %lu, pid = %d\n", pthread_self(), getpid());

	ret = pthread_create(&tid, NULL, thrd_func, NULL);
	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		printf("pthread_create error\n");
		exit(1);
	}
	// sleep(1);
	printf("In main2: pthread id = %lu, pid = %d\n", pthread_self(), getpid());
	// return 0;
	pthread_exit(NULL);
}
```

### 循环创建多个线程

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void *thrd_func(void *arg) {
	int i = (int)arg;
	sleep(i);
	printf("%dtd In thread: pthread id = %lu, pid = %d\n", i+1, pthread_self(), getpid());
	return NULL;
}

int main() {

	pthread_t tid;
	int ret, i;

	for (i = 0; i < 5; ++i) {
		ret = pthread_create(&tid, NULL, thrd_func, (void *)i);
		if (ret != 0) {
			fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
			printf("pthread_create error\n");
			exit(1);
		}
	}
	sleep(i);
	return 0;
}

```

### 回收线程

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>

typedef struct {
	int a;
	int b;
}exit_t;

void *tfn(void *arg) {
	exit_t *ret = (exit_t *) arg;
	ret->a = 100;
	ret->b = 200;
	printf("thread: %p\n", ret);
	pthread_exit((void*) ret);
}

int main() {
  	// int pthread_join(pthread_t thread, void **retval);
	pthread_t tid;
	exit_t *retval = malloc(sizeof(exit_t));
	int ret;

	ret = pthread_create(&tid, NULL, tfn, (void *)retval);
	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		exit(1);
	}
	pthread_join(tid, (void **)&retval);
	printf("main: %p\n", retval);
	printf("a = %d, b = %d\n", retval->a, retval->b);
	free(retval);

	return 0;
}
```

### 线程分离

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void *tfn(void *arg) {
	printf("pthread id : %lu\n", pthread_self());
	pthread_exit(NULL);
}

int main() {

	// int pthread_detach(pthread_t thread);
	// 线程主动和主控线程断开关系，线程结束后退出状态不由其他线程获取，直接释放，无系统残留资源
	pthread_t tid;
	int ret, err;
	void *tret;
	
	ret = pthread_create(&tid, NULL, tfn, NULL);
	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		exit(1);
	}
	pthread_detach(tid);
	while(1) {
		err = pthread_join(tid, (void **)&tret);
		printf("pthread err: %d\n", err);
		if (err != 0) {
			fprintf(stderr, "pthread_join error: %s\n", strerror(err));
		}else {
			fprintf(stderr, "thread exit code: %d\n", (int)tret);
		}
		sleep(1);
	}

	return 0;
}

```

### 取消线程
pthread_cancel, 需要到达一个检查点(取消点, 系统调用)，才能取消线程，可以手动加入取消点，pthread_testcancel()
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void sys_err(char *s, int err) {
	fprintf(stderr, "%s error: %s\n", s, strerror(err));
	exit(1);
}

void *tfn1(void *arg) {
	printf("thread1 is running!\n");
	pthread_exit((void*)111);
}


void *tfn2(void *arg) {
	while (1) {
		printf("thread2 is running!\n");
		sleep(1);
	}
	pthread_exit((void*)222);
}

int main() {
	pthread_t tid;
	int ret;
	void *retval;

	ret = pthread_create(&tid, NULL, tfn1, NULL);
	if (ret != 0) sys_err("pthread_create", ret);
	// pthread_detach(tid);
	ret = pthread_join(tid, (void**)&retval);
	if (ret != 0) sys_err("pthread_jon", ret);
	printf("thread1 retval: %d\n", (int)retval);

	ret = pthread_create(&tid, NULL, tfn2, NULL);
	if (ret != 0) sys_err("pthread_create", ret);
	
	sleep(3);

	ret = pthread_cancel(tid);
	if (ret != 0) sys_err("pthread_cancel", ret);
	ret = pthread_join(tid, (void**)&retval);
	if (ret != 0) sys_err("pthread_jon", ret);
	printf("thread2 retval: %d\n", (int)retval);

	return 0;
}
```
### 线程属性

```c
// 通过线程属性设置线程分离
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *tfn(void *arg){
	pthread_exit(NULL);
}

int main() {
	pthread_t tid;
	int ret;
	pthread_attr_t attr;
	void* retval;

	ret = pthread_attr_init(&attr);
	if (ret != 0) {
		if (ret != 0) {
			fprintf(stderr, "pthread_attr_init error: %s\n", strerror(ret));
			exit(1);
		}
	}

	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
	ret = pthread_create(&tid, &attr, tfn, NULL);

	if (ret != 0) {
		fprintf(stderr, "pthread_create error: %s\n", strerror(ret));
		exit(1);
	}
	
	ret = pthread_join(tid, (void**)&retval);
	printf("pthread_join ret: %d\n", ret);

	pthread_attr_destory(&attr);
	return 0;
}
```
### 互斥量mutex
访问共享资源前加锁，访问结束后立即解锁，锁的"粒度"越小越好

```c
// 加锁 解锁
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

pthread_mutex_t mutex;

void *tfn(void *arg) {
	srand(time(NULL));
	while (1) {
		pthread_mutex_lock(&mutex);
		printf("hello ");
		sleep(rand() % 3); // 模拟失去cpu
		printf("world\n");
		pthread_mutex_unlock(&mutex);
		sleep(rand() % 3);
	}
	return NULL;
}

int main() {
	pthread_t tid;
	srand(time(NULL));
	pthread_mutex_init(&mutex, NULL); // mutex = 1

	pthread_create(&tid, NULL, tfn, NULL);

	while (1) {
		pthread_mutex_lock(&mutex);
		printf("HELLO ");
		sleep(rand() % 3);
		printf("WORLD\n");
		pthread_mutex_unlock(&mutex);
		sleep(rand() % 3);
		
	}

	pthread_mutex_destroy(&mutex);
	return 0;
}
```

### 死锁
- 线程对同一个互斥量加锁两次
- 线程1拥有A锁，请求B锁；线程2拥有B锁，请求A锁

### 读写锁
写独占，读共享，写锁优先级高

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>
int counter;
pthread_rwlock_t rwlock;

void *th_write(void *arg) {
	int t;
	int i = (int) arg;
	printf("i = %d\n", i);
	while (1) {
		t = counter;
		usleep(1000);
		pthread_rwlock_wrlock(&rwlock);
		printf("write %d: %lu: counter = %d ++counter = %d\n", i, pthread_self(), t, ++counter);
		pthread_rwlock_unlock(&rwlock);
		usleep(1000);
	}
	return NULL;
}

void *th_read(void *arg) {
	int i;
	i = (int) arg;
	while (1) {
		pthread_rwlock_rdlock(&rwlock);
		printf("read %d: %lu: counter = %d\n", i, pthread_self(), counter);
		pthread_rwlock_unlock(&rwlock);
		usleep(900);
	}
	return NULL;
}

void sys_err(char *s, int err) {
	fprintf(stderr, "%s error: %s\n", s, strerror(err));
	exit(1);
}
int main() {

	int i, ret;
	pthread_t tid[8];
	pthread_rwlock_init(&rwlock, NULL);
	
	// 创建3个写线程
	for (i = 0; i < 3; ++i) {
		ret = pthread_create(&tid[i], NULL, th_write, (void*)i);
		if (ret != 0) sys_err("pthread_create", ret);
	}
}
```
### 条件变量

```c
// 生产者消费者模型
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

struct msg{
	struct msg *next;
	int num;
};
struct msg *head, *mp;

void *consumer(void *arg) {
	while (1) {
		pthread_mutex_lock(&lock);
		while (head == NULL) { // 多个消费者, 只有一个能抢到资源
			pthread_cond_wait(&has_product, &lock);
		}
		mp = head;
		head = mp->next;
		pthread_mutex_unlock(&lock);

		printf("Consumer -- %d\n", mp->num);
		free(mp);
		mp = NULL;
		sleep(rand() % 3);
	}
}

void *producer(void *p) {
	while (1) {
		mp = malloc(sizeof(struct msg));
		mp->num = rand() % 100 + 1;
		printf("Producer ++ %d\n", mp->num);
		
		pthread_mutex_lock(&lock);
		mp->next = head;
		head = mp;
		pthread_mutex_unlock(&lock);
		// 唤醒等待的线程
		pthread_cond_signal(&has_product); 
		sleep(rand() % 3);
	}
}

int main() {
	pthread_t pid, cid;
	srand(time(NULL));

	pthread_create(&pid, NULL, producer, NULL);
	pthread_create(&cid, NULL, consumer, NULL);

	pthread_join(pid, NULL);
	pthread_join(cid, NULL);

	return 0;
}
```
## 信号量

信号量实现生产者消费模型
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>
#define NUM 5

int queue[NUM];
sem_t blank_number, product_number;

void *producer(void *arg) {
	int i = 0;
	while (1) {
		sem_wait(&blank_number);
		queue[i] = rand() % 100 + 1;
		printf("Produce ++ %d\n", queue[i]);
		sem_post(&product_number);

		i = (i + 1) % NUM;
		sleep(rand() % 1);
	}
}

void *consumer(void *arg) {
	int i = 0;
	while (1) {
		sem_wait(&product_number);
		printf("Consume -- %d\n", queue[i]);
		queue[i] = 0;
		i = (i + 1) % NUM;
		sleep(rand() % 3);
	}
}

int main() {
	pthread_t pid, cid;

	sem_init(&blank_number, 0, NUM);
	sem_init(&product_number, 0, 0);

	pthread_create(&pid, NULL, producer, NULL);
	pthread_create(&cid, NULL, consumer, NULL);

	pthread_join(pid, NULL);
	pthread_join(cid, NULL);

	sem_destroy(&blank_number);
	sem_destroy(&product_number);

	return 0;
}
```

### 进程同步

互斥量实现进程同步
```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <unistd.h>

struct mt{
	int num;
	pthread_mutex_t mutex;
	pthread_mutexattr_t mutexattr;
};

int main() {
	int i;
	struct mt *mm;
	pid_t pid;

	mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);
	memset(mm, 0, sizeof(*mm));
	// 初始化mutex属性对象
	pthread_mutexattr_init(&mm->mutexattr);
	// 设置进程共享
	pthread_mutexattr_setpshared(&mm->mutexattr, PTHREAD_PROCESS_SHARED);
	// 初始化mutex锁
	pthread_mutex_init(&mm->mutex, &mm->mutexattr);

	pid = fork();
	if (pid == 0) {
		for (i = 0; i < 10; ++i) {
			pthread_mutex_lock(&mm->mutex);
			(mm->num)++;
			pthread_mutex_unlock(&mm->mutex);
			printf("child num++ %d\n", mm->num);

			sleep(1);
		}
	}else if(pid > 0) {
		for (i = 0; i < 10; ++i) {
			sleep(1);
			pthread_mutex_lock(&mm->mutex);
			mm->num += 2;
			printf("parent num +=2 %d\n", mm->num);
			pthread_mutex_unlock(&mm->mutex);
		}
		wait(NULL);
	}
	pthread_mutexattr_destroy(&mm->mutexattr);
	pthread_mutex_destroy(&mm->mutex);
	return 0;
}
```

文件锁
```c
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

void sys_err(char *s) {
	perror(s);
	exit(1);
}

int main(int argc, char *argv[]) {
	int fd;
	struct flock f_lock;
	if (argc < 2) {
		printf("./a.out filename\n");
		exit(1);
	}

	if ((fd = open(argv[1], O_RDWR)) < 0) {
		sys_err("open");
	}

	f_lock.l_type = F_WRLCK; // 写锁
	// f_lock.l_type = F_RDLCK; // 读锁
	
	f_lock.l_whence = SEEK_SET;
	f_lock.l_start = 0;
	f_lock.l_len = 0; // 0对整个文件加锁

	fcntl(fd, F_SETLKW, &f_lock);
	printf("get flock\n");
	sleep(10);

	f_lock.l_type = F_UNLCK;
	fcntl(fd, F_SETLKW, &f_lock);
	printf("un flock\n");

	close(fd);

	return 0;
}
```
## 网络编程

man 7 ip
nc localhost 6666 测试连接

接受客户端发送的字符，将小写转为大写发送给客户端

### 简单socket连接

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>
#define SERV_PORT 6666
int main() {

	int lfd, cfd, ret;
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	char buf[BUFSIZ], clie_IP[BUFSIZ];
	int n, i;
	// 创建套接字
	lfd = socket(AF_INET, SOCK_STREAM, 0);
	if (lfd == -1) {
		perror("socket error");
		exit(1);
	}

	// 端口复用
	int opt = 1;
	setsockopt(lfd, SOCK_STREAM, SO_REUSEADDR, &opt, sizeof(opt));

	// 设置协议，ip和端口
	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	// 绑定端口
	ret = bind(lfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
	if (ret == -1) {
		perror("bind error");
		exit(1);
	}
	// 设置同时连接的数量
	ret = listen(lfd, 128);
	if (ret == -1) {
		perror("listen error");
		exit(1);
	}
	
	clie_addr_len = sizeof(clie_addr);
	// 阻塞等待客户端连接
	cfd = accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
	if (cfd == -1) {
		perror("accept error");
		exit(1);
	}
	// 输出连接客户端的信息
	inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP));

	printf("client ip: %s, client port: %d\n", clie_IP, ntohs(clie_addr.sin_port));	
	while (1) {
		n = read(cfd, buf, sizeof(buf));
		for (i = 0; i < n; ++i) {
			buf[i] = toupper(buf[i]);
		}
		write(cfd, buf, n);
	}
	
	close(lfd);

	return 0;
}
```

客户端向服务器发送字符串, 接受服务端发送来的字符串
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#define SERV_PORT 6666
#define SERV_IP "127.0.0.1"

int main() {
	int cfd, n;
	struct sockaddr_in serv_addr;
	socklen_t serv_addr_len;
	serv_addr_len = sizeof(serv_addr);
	// 创建socket
	cfd = socket(AF_INET, SOCK_STREAM, 0);
		
	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	inet_pton(AF_INET, SERV_IP, &serv_addr.sin_addr.s_addr);
	// 链接服务器
	connect(cfd, (struct sockaddr *)&serv_addr, serv_addr_len);

	char buf[BUFSIZ];
	while (1) {
		fgets(buf, sizeof(buf), stdin);
		// 向服务端发送信息
		write(cfd, buf, strlen(buf));
		// 读取服务端发送的消息
		n = read(cfd, buf, sizeof(buf));
		write(STDOUT_FILENO, buf, n);
	}

	close(cfd);
	return 0;
}
```

### 多进程连接

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <strings.h>
#include <ctype.h>
#include "wrap.h"
#include <sys/wait.h>
#define SERV_PORT 8888

void wait_child(int signo) {
	while (waitpid(0, NULL, WNOHANG) > 0);
}

int main() {

	int lfd, cfd;
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	pid_t pid;
	char buf[BUFSIZ], clie_IP[BUFSIZ];
	int n, i;
	lfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	// inet_pton(AF_INET, "192.168.1.101", &serv_addr.sin_addr.s_addr);
	Bind(lfd, (struct scockaddr *)&serv_addr, sizeof(serv_addr));

	Listen(lfd, 128);

	while (1) {
		clie_addr_len = sizeof(clie_addr);
		cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
		
		printf("client IP: %s, client port: %d\n", 
		inet_ntop(AF_INET, &clie_addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP)),
		ntohs(clie_addr.sin_port));
		pid = fork();
		if (pid < 0) {
			perror("fork error");
			exit(1);
		}else if (pid == 0) {
			close(lfd);
			break;
		}else {
			close(cfd);	
			signal(SIGCHLD, wait_child);
		}
	}
	if (pid == 0) {
		while (1) {
			n = Read(cfd, buf, sizeof(buf));
			if (n == 0) {
				return 0;
			}else if(n < 0) {
				perror("read error");
				exit(1);
			}else {
				for (i = 0; i < n; ++i) {
					buf[i] = toupper(buf[i]);
				}
				write(cfd, buf, n);
			}
		}
	}

	return 0;
}
```

### 多线程连接

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <strings.h>
#include <ctype.h>
#include "wrap.h"
#include <sys/wait.h>
#include <pthread.h>
#define SERV_PORT 8888

struct s_info{
	struct sockaddr_in addr;
	int cfd;
};

void *do_work(void *arg) {
	int n, i;
	struct s_info *ts = (struct s_info*) arg;
	char buf[BUFSIZ], clie_IP[BUFSIZ];
	while (1) {
		n = Read((*ts).cfd, buf, sizeof(buf));
		if (n == 0) {
			return 0;
		}else if(n < 0) {
			perror("read error");
			exit(1);
		}else {
			for (i = 0; i < n; ++i) {
				buf[i] = toupper(buf[i]);
			}
			printf("client IP: %s, client port: %d\n", 
			inet_ntop(AF_INET, &(*ts).addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP)),
			ntohs((*ts).addr.sin_port));
			
			write(STDOUT_FILENO, buf, n);
			write((*ts).cfd, buf, n);
		}
	}
}

int main() {
	int lfd, cfd;
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	lfd = Socket(AF_INET, SOCK_STREAM, 0);
	pthread_t tid;
	struct s_info ts[256];
	int i = 0;

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(SERV_PORT);
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	// inet_pton(AF_INET, "192.168.1.101", &serv_addr.sin_addr.s_addr);
	Bind(lfd, (struct scockaddr *)&serv_addr, sizeof(serv_addr));

	Listen(lfd, 128);
	
	while (1) {
		clie_addr_len = sizeof(clie_addr);
		cfd = Accept(lfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
		ts[i].addr = clie_addr;
		ts[i].cfd = cfd;
		
		pthread_create(&tid, NULL, do_work, (void*)&ts[i]);
		pthread_detach(tid);
		++i;
	}
	return 0;
}
```

### select实现并发

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <ctype.h>
#include "wrap.h"

#define SERV_PORT 6666

int main() {
	int i, j, n, maxi;
	// 自定义数组client，防止遍历1024个文件描述符
	int nread, client[FD_SETSIZE];
	int maxfd, listenfd, connfd, sockfd;
	// define INET_ADDRSTRLEN 16, IPV4在char表示的最大的长度
	char buf[BUFSIZ], str[INET_ADDRSTRLEN];
	struct sockaddr_in clie_addr, serv_addr;
	socklen_t clie_addr_len;
	fd_set rset, allset;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
	Listen(listenfd, 128);

	maxfd = listenfd;

	maxi = -1;
	for (i = 0; i < FD_SETSIZE; ++i) {
		client[i] = -1;
	}
	FD_ZERO(&allset);
	FD_SET(listenfd, &allset);

	while (1) {
		rset = allset;
		// 最大文件描述符+1，读文件描述符，写文件描述符， 异常文件描述符，等待时间
		nread = select(maxfd+1, &rset, NULL, NULL, NULL);
		if (nread < 0) {
			perror("select error");
			exit(1);
		}
		// 新的连接
		if (FD_ISSET(listenfd, &rset)) {
			clie_addr_len = sizeof(clie_addr);
			// Accept 不会阻塞
			connfd = Accept(listenfd, (struct sockaddr *)&clie_addr, &clie_addr_len);
			printf("receive from %s at port %d\n", 
					inet_ntop(AF_INET, &clie_addr.sin_addr, str, sizeof(str)),
					ntohs(clie_addr.sin_port));
			// 把Accept返回的文件描述符保存到clientp[]中
			for (i = 0; i < FD_SETSIZE; ++i) {
				if (client[i] < 0) {
					client[i] = connfd;
					break;
				}
			}
			if (i == FD_SETSIZE) {
				fputs("too many clients\n", stderr);
				exit(1);
			}
			FD_SET(connfd, &allset);
			if (connfd > maxfd) {
				maxfd = connfd;
			}
			if (i > maxi) {
				maxi = i;
			}
			if (--nread == 0) {
				continue;
			}
		}
		for (int i = 0; i <= maxi; ++i) {
			if ((sockfd = client[i]) < 0) continue;
			if (FD_ISSET(sockfd, &rset)) {
				// 客户端关闭
				if ((n = Read(sockfd, buf, sizeof(buf))) == 0) {
					close(sockfd);
					FD_CLR(sockfd, &allset);
					client[i] = -1;
				}else if (n > 0) {
					for (j = 0; j < n; ++j) {
						buf[j] = toupper(buf[j]);
					}
					// sleep(5);
					Writen(sockfd, buf, n);
				}
				if (--nread == 0) break;
			}
		}
	}
	Close(listenfd);
	return 0;
}
```
### poll实现并发

```bash
# 查看进程可以打开socket描述符的上限
cat /proc/sys/fs/file-max 
# 修改上限值
vim /etc/security/limits.conf 
# 尾部添加soft软限制，hard硬限制
* soft nofile 65536
* hard nofile 100000
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <poll.h>
#include <string.h>
#include <netinet/in.h>
#include <errno.h>
#include "wrap.h"
#define SERV_PORT 6666
#define MAXLINE 80
#define OPEN_MAX 1024
int main() {
	int i, j, maxi, listenfd, connfd, sockfd;
	int nready;
	ssize_t n;
	
	char buf[BUFSIZ], str[INET_ADDRSTRLEN];
	socklen_t clien;
	struct pollfd client[OPEN_MAX];
	struct sockaddr_in servaddr, clieaddr;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	// 设置端口复用
	int opt = 1;
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));
	Listen(listenfd, 128);

	client[0].fd = listenfd;
	client[0].events = POLLIN;
	for (i = 1; i < OPEN_MAX; ++i) {
		client[i].fd = -1;
	}
	maxi = 0;
	while (1) {
		// 阻塞监听是否有新的链接请求
		nready = poll(client, maxi+1, -1);
		if (client[0].revents & POLLIN) {
			clien = sizeof(clieaddr);
			connfd = Accept(listenfd, (struct sockaddr *)&clieaddr, &clien);
			printf("received from %s at PORT %d\n",
					inet_ntop(AF_INET, &clieaddr.sin_addr, str, sizeof(str)),
					ntohs(clieaddr.sin_port));
			// 把Accept返回的connfd，放到client[]中
			for (i = 1; i < OPEN_MAX; ++i) {
				if (client[i].fd < 0) {
					client[i].fd = connfd;
					break;
				}
			}
			
			if (i == OPEN_MAX) {
				perror("too many clients");
				exit(1);
			}
			// 监听新连接的客户端的读时间
			client[i].events = POLLIN;
			// 更新client[]中的最大下标
			if (i > maxi) maxi = i;
			// 判断时候有读写事件
			if (--nready == 0) continue;
		}

		// 找到对应的客户端，处理请求
		for (i = 1; i <= maxi; ++i) {
			if ((sockfd = client[i].fd) < 0) {
				continue;
			}

			if (client[i].revents & POLLIN) {
				if ((n = Read(sockfd, buf, MAXLINE)) < 0) {
					// 连接重置
					if (errno == ECONNRESET) {
						printf("client[%d] aborted connection\n", i);
						Close(sockfd);
						client[i].fd = -1;
					}else {
						perror("read error");
						exit(1);
					}
				}else if (n == 0) {
					printf("client[%d] closed connection\n", i);
					Close(sockfd);
					client[i].fd = -1;
				}else {
					for (j = 0; j < n; ++j) {
						buf[j] = toupper(buf[j]);
					}
					Writen(sockfd, buf, n);
				}
				if (--nready == 0) break;
			}
		}
	}
	return 0;
}
```
### epoll实现并发

epoll_create();
epoll_ctl();
epoll_wait();

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <sys/epoll.h>
#include <string.h>
#include <netinet/in.h>
#include <errno.h>
#include "wrap.h"
#define SERV_PORT 6666
#define MAXLINE 8000
#define OPEN_MAX 5000
int main() {
	int i, j, listenfd, connfd, sockfd;
	int n;
	ssize_t nready, efd, res;
	char buf[MAXLINE], str[INET_ADDRSTRLEN];
	socklen_t clilen;
	struct sockaddr_in cliaddr, servaddr;
	struct epoll_event tep, ep[OPEN_MAX];

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	int opt = 1;
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));
	Listen(listenfd, 128);
	// 创建epoll模型，edf指向红黑树的根节点
	efd = epoll_create(OPEN_MAX);
	if (efd == -1) {
		perror("epoll create");
		exit(1);
	}
	// listenfd为监听的读事件
	tep.events = EPOLLIN;
	tep.data.fd = listenfd;
	// 将listenfd插到epoll树上
	res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &tep);
	if (res == -1) {
		perror("epoll_ctl error");
		exit(1);
	}
	while (1) {
		nready = epoll_wait(efd, ep, OPEN_MAX, -1);
		if (nready == -1) {
			perror("epoll_wait error");
			exit(1);
		}
		for (i = 0; i < nready; ++i) {
			if (!(ep[i].events & EPOLLIN)) {
				continue;
			}
			if (ep[i].data.fd == listenfd) {
				clilen = sizeof(cliaddr);
				connfd = Accept(listenfd, (struct sockaddr *)&cliaddr, &clilen);
				printf("reveived from %s at port %d\n", 
						inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)),
						ntohs(cliaddr.sin_port));
				tep.events = EPOLLIN;
				tep.data.fd = connfd;
				res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &tep);
				if (res == -1) {
					perror("epoll_ctl error");
					exit(1);
				}
			}else {
				sockfd = ep[i].data.fd;
				n = Read(sockfd, buf, MAXLINE);
				if (n == 0) {
					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);
					if (res == -1) {
						perror("epoll_ctl error");
						exit(1);
					} 
					printf("client[%d] close connection\n", sockfd);
					Close(sockfd);
				} else if (n > 0) {
					for (j = 0; j < n; ++j) {
						buf[j] = toupper(buf[j]);
					}
					Writen(sockfd, buf, n);
					Writen(STDOUT_FILENO, buf, n);
				}else if (n < 0) {
					perror("read error");
					res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, NULL);
					if (res == -1) {
						perror("epoll_ctl DEL error");
						exit(1);
					}
					Close(sockfd);
				}
			}
		}
	}


	return 0;
}
```
### epoll 水平触发和边沿触发

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <errno.h>
#include <unistd.h>
#define MAXLINE 10

int main() {
	
	int efd, i;
	int pfd[2];
	pid_t pid;
	char buf[MAXLINE], ch = 'a';

	pipe(pfd);
	pid = fork();
	// 子写，父读
	if (pid == 0) {
		close(pfd[0]);
		while (1) {
			for (i = 0; i < MAXLINE/2; ++i) {
				buf[i] = ch;
			}
			buf[i-1] = '\n';
			ch++;
			for (; i < MAXLINE; ++i) {
				buf[i] = ch; 
			}
			buf[i-1] = '\n';
			ch++;
			write(pfd[1], buf, sizeof(buf));
			sleep(3);
		}
		close(pfd[1]);
	} else if(pid > 0) {
		struct epoll_event event;
		struct epoll_event resevent[10];
		int res, len;

		close(pfd[1]);
		efd = epoll_create(10);

		event.events = EPOLLIN | EPOLLET; // ET边沿触发
		// event.events = EPOLLIN; // LT水平触发(默认)
		event.data.fd = pfd[0];
		res = epoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &event);
		if (res == -1) {
			perror("epoll_ctl error");
			exit(1);
		}

		while (1) {
			res = epoll_wait(efd, resevent, 10, -1);
			printf("res %d\n", res);
			if (resevent[0].data.fd == pfd[0]) {
				len = read(pfd[0], buf, MAXLINE/2);
				write(STDOUT_FILENO, buf, len);
			}
		}
	}
	
	return 0;
}
```

### epoll 非阻塞IO
使用边沿epoll，减少epoll_wait
while读取数据
fcntl设置非阻塞读

```c
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/epoll.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>

#define MAXLINE 10
#define SERV_PORT 6666
#define SERV_IP "127.0.0.1"

int main() {
	struct sockaddr_in servaddr, cliaddr;
	socklen_t cliaddr_len;
	int listenfd, connfd;
	char buf[BUFSIZ];
	char str[INET_ADDRSTRLEN];
	int efd, flag;
	
	listenfd = socket(AF_INET, SOCK_STREAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	inet_pton(AF_INET, SERV_IP, &servaddr.sin_addr.s_addr);
	// servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);
	
	bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));

	listen(listenfd, 20);

	cliaddr_len = sizeof(cliaddr);
	connfd = accept(listenfd, (struct sockaddr *)&cliaddr, &cliaddr_len);
	printf("receive from %s port %d\n", inet_ntop(AF_INET, &cliaddr.sin_family, str, sizeof(str)),
			ntohs(cliaddr.sin_port));

	// 修改connfd为非阻塞读
	flag = fcntl(connfd, F_GETFL);
	flag |= O_NONBLOCK;
	fcntl(connfd, F_SETFL, flag);

	struct epoll_event event;
	struct epoll_event resevent[10];
	int res, len;
	
	efd = epoll_create(10);
	event.events = EPOLLIN | EPOLLET;
	event.data.fd = connfd;

	epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &event);
	while (1) {
		printf("epoll_wait...\n");
		res = epoll_wait(efd, resevent, 10, -1);
		printf("epoll_wait end res %d\n", res);

		if (resevent[0].data.fd == connfd) {
			while ((len = read(connfd, buf, MAXLINE/2)) > 0) {
				write(STDOUT_FILENO, buf, len);
			}
		}
	}

	return 0;
}
```

### epoll 基于非阻塞I/O事件驱动 (反应堆模型)
libevent的核心思想

1. epoll
服务器监听fd, 可读epoll返回, read之后处理数据, write写回, epoll继续监听

2. epoll反应堆模型
服务器监听cfd, 可读epoll返回, read之后将cfd从树上摘下, 设置epoll监听的写事件, 处理数据, 等待epoll_wait返回写回客户端, 将cfd从树上摘下, 设置cfd的读事件继续监听

```c
// epoll_loop.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <time.h>

#define MAX_EVENTS 1024
#define BUFLEN 4096
#define SERV_PORT 6666

void recvdata(int fd, int events, void *arg);
void senddata(int fd, int events, void *arg);

// 描述就绪文件描述符相关信息
struct myevent_s{
	int fd;
	int events;
	void *arg;											// 泛型指针
	void (*call_back)(int fd, int events, void *arg);	// 回调函数
	int status;											// 是否在监听 1->在红黑树上, 0->不在红黑树上
	char buf[BUFLEN];
	int len;
	long last_active;									// 记录每次加入红黑树上 g_efd 的时间值
};

int g_efd;												// 保存epoll_create返回的文件描述符
struct myevent_s g_events[MAX_EVENTS+1];				// 自定义结构体类型数组, +1->listenfd

// 初始化myevent_s 成员变量
void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg) {
	ev->fd = fd;
	ev->call_back = call_back;
	ev->events = 0;
	ev->arg = arg;
	ev->status = 0;
	// memset(ev->buf, 0, sizeof(ev->buf));
	// ev->len = 0;
	ev->last_active = time(NULL);
	return;
}

// 向epoll监听的红黑树插入文件描述符
void eventadd(int efd, int events, struct myevent_s *ev) {
	struct epoll_event epv = {0, {0}};
	int op;
	epv.data.ptr = ev;
	epv.events = ev->events = events;

	if (ev->status == 1) {
		op = EPOLL_CTL_MOD;
	}else {
		op = EPOLL_CTL_ADD;
		ev->status = 1;
	}

	if (epoll_ctl(efd, op, ev->fd, &epv) < 0) {
		printf("event add faild [fd=%d], events[%d]\n", ev->fd, events);
	}else {
		printf("event add OK [fd=%d], op = %d, events[%0X]\n", ev->fd, op, events);
	}
	return;
}

// 从epoll监听的红黑树删除文件描述符
void eventdel(int efd, struct myevent_s *ev) {
	struct epoll_event epv = {0, {0}};
	if (ev->status != 1) {
		return;
	}
	epv.data.ptr = ev;
	ev->status = 0;
	epoll_ctl(efd, EPOLL_CTL_DEL, ev->fd, &epv);
	return;
}

// 当文件描述符就绪, epoll返回, 调用函数与客户端建立连接
void acceptconn(int lfd, int events, void *arg) {
	struct sockaddr_in cin;
	socklen_t len = sizeof(cin);
	int cfd, i;

	if ((cfd = accept(lfd, (struct sockaddr *)&cin, &len)) == -1) {
		if (errno != EAGAIN && errno != EINTR) {
			// 出错处理
		}
		printf("%s: accept, %s\n", __func__, strerror(errno));
		return;
	}

	do{
		// 在g_events中为cfd找个位置存
		for (i = 0; i < MAX_EVENTS; ++i) {
			if(g_events[i].status == 0) {
				break;
			}
			if (i == MAX_EVENTS) {
				printf("%s: max connect limit[%d]\n", __func__, MAX_EVENTS);
				break;
			}
		}
		int flag = 0;
		if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) < 0) {
			printf("%s: fcntl nonblocking failed, %s\n", __func__, strerror(errno));
			break;
		}
		// 给cfd设置一个myevent_s的结构体, 回调函数设置为recvdata
		eventset(&g_events[i], cfd, recvdata, &g_events[i]);
		eventadd(g_efd, EPOLLIN, &g_events[i]);
	}while (0);
	
	printf("new connect [%s:%d][time:%ld], pos[%d]\n",
		inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);
	return;
}

void recvdata(int fd, int events, void *arg) {
	struct myevent_s *ev = (struct myevent_s *) arg;
	int len;
	len = recv(fd, ev->buf, sizeof(ev->buf), 0);

	eventdel(g_efd, ev);				// 删除fd

	if (len > 0) {
		ev->len = len;
		ev->buf[len] = '\0';
		printf("C[%d]:%s\n", fd, ev->buf);

		// printf("send before set len = %d %s\n", ev->len, ev->buf);
		eventset(ev, fd, senddata, ev);	// 设置fd的回调函数为senddata
		// printf("send before add len = %d %s\n", ev->len, ev->buf);
		eventadd(g_efd, EPOLLOUT, ev);	// 将fd加到红黑树上, 监听写事件
	}else if(len == 0) {
		close(ev->fd);
		eventdel(g_efd, ev);
		printf("[fd=%d] pos[%ld] closed\n", fd, ev - g_events);
	}else {
		close(ev->fd);
		eventdel(g_efd, ev);
		printf("recv[fd=%d] error[%d]:%s\n", fd, errno, strerror(errno));
	}
	return;
}

void senddata(int fd, int events, void *arg) {
	struct myevent_s *ev = (struct myevent_s *) arg;
	int len;
	// printf("send len ======= %d, %s\n", ev->len, ev->buf);
	len = send(fd, ev->buf, ev->len, 0); // 将数据写回客户端
	if (len > 0) {
		printf("send[fd=%d], [%d]%s\n", fd, len, ev->buf);
		eventdel(g_efd, ev);			// 删除fd
		eventset(ev, fd, recvdata, ev);	// 修改fd为读事件
		eventadd(g_efd, EPOLLIN, ev);	// 向红黑树上插入fd的读事件
	}else {
		close(ev->fd);
		eventdel(g_efd, ev);
		printf("send[fd=%d] error %s\n", fd, strerror(errno));
	}
	return;
}

// 创建socket, 初始化lfd
void initlistensocket(int efd, short port) {
	int lfd = socket(AF_INET, SOCK_STREAM, 0);
	fcntl(lfd, F_SETFL, O_NONBLOCK); // 设置socket为非阻塞
	eventset(&g_events[MAX_EVENTS], lfd, acceptconn, &g_events[MAX_EVENTS]);
	eventadd(efd, EPOLLIN, &g_events[MAX_EVENTS]);

	struct sockaddr_in sin;
	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_port = htons(port);
	bind(lfd, (struct sockaddr *)&sin, sizeof(sin));
	listen(lfd, 20);
	return;
}

int main(int argc, char *argv[]) {
	unsigned short port = SERV_PORT;
	if (argc == 2) {
		port = atoi(argv[1]);
	}
	g_efd = epoll_create(MAX_EVENTS+1);	// 创建红黑树, g_efd
	if (g_efd <= 0) {
		printf("create efd in %s err %s\n", __func__, strerror(errno));
	}
	initlistensocket(g_efd, port);		// 初始化监听socket
	struct epoll_event events[MAX_EVENTS+1];	// 保存满足条件的就绪事件的文件描述符集合
	printf("server running:port[%d]\n", port);

	int checkpos = 0, i;
	while (1) {
		// 超时验证, 每次测试100个链接, 不测试listenfd.
		// 当客户端在60秒内没有和服务器通信, 关闭客户端的链接
		long now = time(NULL);
		for (i = 0; i < 100; ++i, ++checkpos) {
			if (checkpos == MAX_EVENTS) checkpos = 0;
			if (g_events[checkpos].status == 0) continue;

			long duration = now - g_events[checkpos].last_active; // 计算客户不活跃的时间
			if (duration >= 60) {
				close(g_events[checkpos].fd);					  // 关闭客户端的连接
				eventdel(g_efd, &g_events[checkpos]);			  // 将对应的文件描述符从红黑树上删除
				printf("[fd=%d] timeout\n", g_events[checkpos].fd);
			}
		}

		// 监听红黑树, 将满足的事件的文件描述符加到events数组中, 1秒没有事件满足返回0
		int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);
		if (nfd < 0) {
			printf("epoll wait error, exit\n");
			break;
		}

		for (i = 0; i < nfd; ++i) {
			struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;
			if ((events[i].events & EPOLLIN) && (ev->events & EPOLLIN)) { // 读事件
				ev->call_back(ev->fd, events[i].events, ev->arg);
			}
			if ((events[i].events & EPOLLOUT) && (ev->events & EPOLLOUT)) { // 写事件
				ev->call_back(ev->fd, events[i].events, ev->arg);
			}
		}
	}
	return 0;
}
```
### 进程池

设置线程池的最小值和最大值, 开始默认创建最小值个线程, 阻塞等待条件变量任务队列不为空.
维护任务队列, 将客户端的连接加到任务队列中, 同时唤醒等待的线程.
线程唤醒之后任务队列中的任务, 并发出任务队列不为满的信号, 让阻塞的客户端继续放任务
管理者线程每隔一段时间, 对当前线程进行管理
 - 当任务队列中的任务数量 > 最小的线程数 且 存活的线程数 < 最小线程数 时按照步长创建新的线程
 - 当忙线程的数量 * 2 < 存活的线程数 且 存活的线程数 > 最小线程数 时按照步长销毁线程

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include "threadpool.h"

#define DEFAULT_TIME 10					// 10s检测一次
#define MIN_WAIT_TASK_NUM 10			// 如果queue_size > MIN_WAIT_TASK_NUM 添加新的线程到线程池
#define DEFAULT_THREAD_VARY 10				// 每次创建和销毁线程的个数
#define true 1
#define false 0
typedef struct{
	void *(*function)(void *);			// 函数指针, 回调函数
	void *arg;							// 函数的参数
}threadpool_task_t;						// 子线程的任务结构体

// 描述线程的相关信息
struct threadpool_t{
	pthread_mutex_t lock;				// 用于锁住结构体
	pthread_mutex_t thread_counter;		// 记录忙状态线程的个数的锁
	pthread_cond_t queue_not_full;		// 当任务队列为满, 添加任务的线程阻塞, 等待此条件变量
	pthread_cond_t queue_not_empty;		// 任务队队列不为空是, 通知等待任务的线程

	pthread_t *threads;					// 存放线程池中的每个线程的tid
	pthread_t adjust_tid;				// 管理者线程
	threadpool_task_t *task_queue;		// 任务队列

	int min_thr_num;					// 线程池最小线程数
	int max_thr_num;					// 线程池最大线程数
	int live_thr_num;					// 当前存活的线程数
	int busy_thr_num;					// 忙线程的个数
	int wait_exit_thr_num;				// 要销毁线程的个数

	int queue_front;					// 任务队列的队首
	int queue_rear;						// 任务队列的对位
	int queue_size;						// 任务队列中的实际任务数量
	int queue_max_size;					// 任务队列可容纳的最大任务数
	
	int shutdown;						// 标志位, 线程池的使用状态
};

void *threadpool_thread(void *threadpool);
void *adjust_thread(void *threadpool);
int is_thread_alive(pthread_t tid);
int threadpool_free(threadpool_t *pool);

threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size) 
{
	int i;
	threadpool_t *pool = NULL;
	do{
		if ((pool = (threadpool_t *)malloc(sizeof(threadpool_t))) == NULL) {
			printf("malloc threadpool fail\n");
			break;
		}

		pool->min_thr_num = min_thr_num;
		pool->max_thr_num = max_thr_num;
		pool->busy_thr_num = 0;
		pool->live_thr_num = min_thr_num;
		pool->queue_size = 0;
		pool->queue_max_size = queue_max_size;
		pool->queue_front = 0;
		pool->queue_rear = 0;
		pool->shutdown = false;

		// 更具最大线程上限数, 创建工作线程数组并清零
		pool->threads = (pthread_t*) malloc(sizeof(pthread_t) * max_thr_num);
		if (pool->threads == NULL) {
			printf("malloc threads fail\n");
			break;
		}
		memset(pool->threads, 0, sizeof(pthread_t) * max_thr_num);

		// 为任务队列开辟空间
		pool->task_queue = (threadpool_task_t *) malloc(sizeof(threadpool_task_t) * queue_max_size);
		if (pool->task_queue == NULL) {
			printf("malloc task_queue fail\n");
			break;
		}

		// 初始化互斥锁, 条件变量
		if (pthread_mutex_init(&(pool->lock), NULL) != 0 ||
			pthread_mutex_init(&(pool->thread_counter), NULL) != 0 ||
			pthread_cond_init(&(pool->queue_not_full), NULL) != 0 ||
			pthread_cond_init(&(pool->queue_not_empty), NULL) != 0)
		{
			printf("init the lock or cond fail\n");
			break;
		}

		// 创建待命的线程
		for (i = 0; i < min_thr_num; ++i) {
			pthread_create(&(pool->threads[i]), NULL, threadpool_thread, (void *)pool);
			printf("start thread 0x%x...\n", (unsigned int)pool->threads[i]);
		}
		// 创建管理者线程
		pthread_create(&(pool->adjust_tid), NULL, adjust_thread, (void *)pool);

		return pool;
	}while(0);

	threadpool_free(pool);
	return NULL;
}


// 向线程池中添加一个任务
int threadpool_add(threadpool_t *pool, void *(*function)(void *arg), void *arg) 
{
	pthread_mutex_lock(&(pool->lock));
	// 队列已满, wait阻塞
	while ((pool->queue_size == pool->queue_max_size) && (!pool->shutdown)) {
		pthread_cond_wait(&(pool->queue_not_full), &(pool->lock));
	}
	if (pool->shutdown) {
		pthread_mutex_unlock(&(pool->lock));
	}

	// 清空工作线程, 调用回调函数
	if (pool->task_queue[pool->queue_rear].arg != NULL) {
		free(pool->task_queue[pool->queue_rear].arg);
		pool->task_queue[pool->queue_rear].arg = NULL;
	}

	// 添加任务到任务队列中
	pool->task_queue[pool->queue_rear].function = function;
	pool->task_queue[pool->queue_rear].arg = arg;
	pool->queue_rear = (pool->queue_rear + 1) % pool->queue_max_size;
	pool->queue_size++;

	// 添加任务后队列不为空, 唤醒线程池中等待的线程
	pthread_cond_signal(&(pool->queue_not_empty));
	pthread_mutex_unlock(&(pool->lock));
	return 0;
}

// 线程池中工作的线程
void *threadpool_thread(void *threadpool) 
{
	threadpool_t *pool = (threadpool_t *)threadpool;
	threadpool_task_t task;

	while (true) {
		pthread_mutex_lock(&(pool->lock));
		
		// 刚创建的线程阻塞等待任务队列有任务在唤醒处理任务
		while((pool->queue_size == 0) && (!pool->shutdown)) {
			printf("thread 0x%x is waitting\n", (unsigned int)pthread_self());
			pthread_cond_wait(&(pool->queue_not_empty), &(pool->lock));
			// 清除指定数目的空闲线程, 如果结束的线程个数大于0, 结束线程
			if (pool->wait_exit_thr_num > 0) {
				pool->wait_exit_thr_num--;
				if (pool->live_thr_num > pool->min_thr_num) {
					printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
					pool->live_thr_num--;
					pthread_mutex_unlock(&(pool->lock));
					pthread_exit(NULL);
				}
			}
		}
		
		// 关闭线程池
		if (pool->shutdown) {
			pthread_mutex_unlock(&(pool->lock));
			printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
			pthread_exit(NULL);
		}

		// 从任务队列中获取任务, 出队
		task.function = pool->task_queue[pool->queue_front].function;
		task.arg = pool->task_queue[pool->queue_front].arg;
		pool->queue_front = (pool->queue_front + 1) % pool->queue_max_size;
		pool->queue_size--;
		
		// 通知可以有新的任务进来
		pthread_cond_broadcast(&(pool->queue_not_full));
		
		// 取出任务之后, 释放线程锁
		pthread_mutex_unlock(&(pool->lock));

		// 执行任务
		printf("thread 0x%x start working\n", (unsigned int)pthread_self());
		pthread_mutex_lock(&(pool->thread_counter));
		pool->busy_thr_num++;
		pthread_mutex_unlock(&(pool->thread_counter));
		// 执行回调函数
		(*(task.function))(task.arg);
		
		printf("thread 0x%x end working\n", (unsigned int)pthread_self());
		pthread_mutex_lock(&(pool->thread_counter));
		pool->busy_thr_num--;
		pthread_mutex_unlock(&(pool->thread_counter));
	}
	pthread_exit(NULL);
}

// 管理线程
void *adjust_thread(void *threadpool) 
{
	int i;
	threadpool_t *pool = (threadpool_t*) threadpool;
	while (!pool->shutdown) {
		sleep(DEFAULT_TIME); 	// 定时对线程池进行管理

		pthread_mutex_lock(&(pool->lock));
		int queue_size = pool->queue_size;
		int live_thr_num = pool->live_thr_num;
		pthread_mutex_unlock(&(pool->lock));

		pthread_mutex_lock(&(pool->thread_counter));
		int busy_thr_num = pool->busy_thr_num;
		pthread_mutex_unlock(&(pool->thread_counter));

		// 创建新线程
		// 当任务数 > 最小线程个数 && 存活的线程数 < 最大线程个数
		if (queue_size >= MIN_WAIT_TASK_NUM &&  live_thr_num < pool->max_thr_num) {
			pthread_mutex_lock(&(pool->lock));
			int add = 0;
			
			// 每次增加DEFAULT_THREAD个线程
			for (i = 0; i < pool->max_thr_num && add < DEFAULT_THREAD_VARY && live_thr_num < pool->max_thr_num; ++i) {
				if (pool->threads[i] == 0 || !is_thread_alive(pool->threads[i])) {
					pthread_create(&(pool->threads[i]), NULL, threadpool_thread, (void*)pool);
					add++;
					pool->live_thr_num++;
				}
			}
			
			pthread_mutex_unlock(&(pool->lock));
		}

		// 清理线程
		// 忙线程 * 2 < 存活的线程 && 存活线程数 > 最小线程数
		if ((busy_thr_num * 2) < live_thr_num && live_thr_num > pool->min_thr_num) {
			pthread_mutex_lock(&(pool->lock));
			pool->wait_exit_thr_num = DEFAULT_THREAD_VARY;
			pthread_mutex_unlock(&(pool->lock));
			for (i = 0; i < DEFAULT_THREAD_VARY; ++i) {
				// 唤醒空闲的线程, 让他们自杀...
				pthread_cond_signal(&(pool->queue_not_empty));
			}
		}
	}
	return NULL;
}

int threadpool_destroy(threadpool_t *pool) 
{
	int i;
	if (pool == NULL) {
		return -1;
	}
	pool->shutdown = true;

	// 销毁管理线程
	pthread_join(pool->adjust_tid, NULL);
	
	for (i = 0; i < pool->live_thr_num; ++i) {
		pthread_cond_broadcast(&(pool->queue_not_empty));
	}
	for (i = 0; i < pool->live_thr_num; ++i) {
		pthread_join(pool->threads[i], NULL);
	}
	threadpool_free(pool);
	return 0;
}

int threadpool_free(threadpool_t *pool) 
{
	if (pool == NULL) {
		return -1;
	}
	if (pool->task_queue) {
		free(pool->task_queue);
	}
	if (pool->threads) {
		free(pool->threads);
		pthread_mutex_lock(&(pool->lock));
		pthread_mutex_destroy(&(pool->lock));
		pthread_mutex_lock(&(pool->thread_counter));
		pthread_mutex_destroy(&(pool->thread_counter));
		pthread_cond_destroy(&(pool->queue_not_empty));
		pthread_cond_destroy(&(pool->queue_not_full));
	}
	free(pool);
	pool = NULL;
	return 0;
}

int threadpool_all_threadnum(threadpool_t *pool) 
{
	int all_threadnum = -1;
	pthread_mutex_lock(&(pool->lock));
	all_threadnum = pool->live_thr_num;
	pthread_mutex_unlock(&(pool->lock));
	return all_threadnum;
}

int threadpool_busy_threadnum(threadpool_t *pool) 
{
	int busy_threadnum = -1;
	pthread_mutex_lock(&(pool->thread_counter));
	busy_threadnum = pool->busy_thr_num;
	pthread_mutex_unlock(&(pool->thread_counter));
	return busy_threadnum;
}

int is_thread_alive(pthread_t tid) 
{
	// 发送0信号, 测试线程是否存活
	int kill_rc = pthread_kill(tid, 0);
	if (kill_rc == ESRCH) return false;
	return true;
}

// 测试

#if 1

void *process(void *arg) 
{
	printf("thread 0x%x working on task %d\n", (unsigned int)pthread_self(), *(int*)arg);
	sleep(1);
	printf("task %d is end\n", *(int*)arg);
	return NULL;
}

int main() {

	threadpool_t *thp = threadpool_create(3, 100, 100);
	printf("pool inited\n");
	sleep(3);

	int num[20], i;
	for (i = 0; i < 20; ++i) {
		num[i] = i;
		printf("add task %d\n", i);
		// 向线程池添加任务
		threadpool_add(thp, process, (void*)&num[i]);
	}

	sleep(10);
	threadpool_destroy(thp);
	return 0;
}

#endif
```

## UDP

### C/S模型

```c
// server.c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <ctype.h>

#define SERV_PORT 6666

int main() {
	
	struct sockaddr_in serv_addr, clie_addr;
	socklen_t clie_addr_len;
	int sockfd;
	char buf[BUFSIZ];
	char str[INET_ADDRSTRLEN];
	int i, n;

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	bzero(&serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(SERV_PORT);
	
	bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

	printf("Accepting connections ...\n");

	while (1) {
		clie_addr_len = sizeof(clie_addr);
		n = recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&clie_addr, &clie_addr_len);
		if (n == -1) {
			perror("recvfrom error");
			exit(1);
		}

		printf("received from %s at port %d\n",
				inet_ntop(AF_INET, &clie_addr, str, sizeof(str)),
				ntohs(clie_addr.sin_port));

		for (i = 0; i < n; ++i) {
			buf[i] = toupper(buf[i]);
		}

		n = sendto(sockfd, buf, n, 0, (struct sockaddr *)&clie_addr, sizeof(clie_addr));
		if (n == -1) {
			perror("sendto error");
			exit(1);
		}
	}
	close(sockfd);

	return 0;
}
```

```c
// client.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>
#include <ctype.h>

#define SERV_PORT 6666

int main() {
	struct sockaddr_in servaddr;
	int sockfd, n;
	char buf[BUFSIZ];

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	inet_pton(AF_INET, "127.0.0.1", &servaddr.sin_addr);
	servaddr.sin_port = htons(SERV_PORT);

	while (fgets(buf, BUFSIZ, stdin) != NULL) {
		n = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&servaddr, sizeof(servaddr));
		if (n == -1) {
			perror("sendto error");
		}

		n = recvfrom(sockfd, buf, BUFSIZ, 0, NULL, 0);	// NULL 不关心对端信息
		if (n == -1) {
			perror("recvfrom error");
		}

		write(STDOUT_FILENO, buf, n);
	}
	return 0;
}
```

### 广播

```c
//server.c
#include <stdio.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define SERVER_PORT 6666
#define MAXLINE 1500
#define BROADCAST_IP "192.168.154.255"
#define CLIENT_PORT 7777

int main() {
	int sockfd;
	struct sockaddr_in serveraddr, clientaddr;
	char buf[BUFSIZ];

	// 构造UDP的套接字
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	bzero(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVER_PORT);
	
	bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));

	int flag = 1;
	// 设置套接字广播权限
	setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &flag, sizeof(flag));
	
	//设置client地址, IP+port 192.168.154.255+7777
	bzero(&clientaddr, sizeof(clientaddr));
	clientaddr.sin_family = AF_INET;
	inet_pton(AF_INET, BROADCAST_IP, &clientaddr.sin_addr.s_addr);
	clientaddr.sin_port = htons(CLIENT_PORT);

	int i = 0;
	while (1) {
		sprintf(buf, "Drink %d glasses of water\n", ++i);
		// fgets(buf, sizeof(buf), stdin);
		int ret = sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&clientaddr, sizeof(clientaddr));
		if (ret == -1) {
			perror("sendto error");
			exit(1);
		}
		sleep(1);
	}

	close(sockfd);

	return 0;
}
```

```c
//client.c
#include <stdio.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>

#define SERVER_PORT 6666
#define MAXLINE 4096
#define CLIENT_PORT 7777

int main() {
	struct sockaddr_in localaddr;
	int confd;
	ssize_t len;
	char buf[MAXLINE];

	confd = socket(AF_INET, SOCK_DGRAM, 0);
	bzero(&localaddr, sizeof(localaddr));
	localaddr.sin_family = AF_INET;
	inet_pton(AF_INET, "0.0.0.0", &localaddr.sin_addr.s_addr);
	localaddr.sin_port = htons(CLIENT_PORT);

	int ret = bind(confd, (struct sockaddr *)&localaddr, sizeof(localaddr));
	if (ret == 0) {
		printf("..bind ok ...\n");
	}
	while (1) {
		len = recvfrom(confd, buf, sizeof(buf), 0, NULL, 0);
		write(STDOUT_FILENO, buf, len);
	}
	
	close(confd);
	return 0;
}
```

### 组播


```bash
# 查看网卡编号
ip ad
```
```c
//server.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <net/if.h>

#define SERVER_PORT 6666
#define CLIENT_PORT 7777
#define MAXLINE 1500
#define GROUP "239.0.0.2"

int main() {
	int sockfd;
	struct sockaddr_in serveraddr, clientaddr;
	char buf[MAXLINE] = "kali@root\n";
	struct ip_mreqn group;
	
	sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	bzero(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serveraddr.sin_port = htons(SERVER_PORT);

	bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr));
	// 设置组地址
	inet_pton(AF_INET, GROUP, &group.imr_multiaddr);
	// 指定本机地址
	inet_pton(AF_INET, "0.0.0.0", &group.imr_address);
	// 获取eth0对应网卡的编号
	group.imr_ifindex = if_nametoindex("eth0");

	// 组播权限
	setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_IF, &group, sizeof(group));

	bzero(&clientaddr, sizeof(clientaddr));
	clientaddr.sin_family = AF_INET;
	inet_pton(AF_INET, GROUP, &clientaddr.sin_addr.s_addr);
	clientaddr.sin_port = htons(CLIENT_PORT);

	int i = 0;
	while (1) {
		sprintf(buf, "kali@root %d\n", ++i);
		sendto(sockfd, buf, strlen(buf), 0, (struct sockaddr *)&clientaddr, sizeof(clientaddr));
		sleep(1);
	}
	
	close(sockfd);
	return 0;
}
```

```c
//client.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <net/if.h>

#define SERVER_PORT 6666
#define CLIENT_PORT 7777
#define GROUP "239.0.0.2"

int main() {
	struct sockaddr_in localaddr;
	int confd;
	ssize_t len;
	char buf[BUFSIZ];

	struct ip_mreqn group;

	confd = socket(AF_INET, SOCK_DGRAM, 0);
	
	bzero(&localaddr, sizeof(localaddr));
	localaddr.sin_family = AF_INET;
	inet_pton(AF_INET, "0.0.0.0", &localaddr.sin_addr.s_addr);
	localaddr.sin_port = htons(CLIENT_PORT);
	
	bind(confd, (struct sockaddr *)&localaddr, sizeof(localaddr));

	// 设置组播地址
	inet_pton(AF_INET, GROUP, &group.imr_multiaddr);
	// 将本地IP添加到组播组中
	inet_pton(AF_INET, "0.0.0.0", &group.imr_address);
	// 获取网卡编号
	group.imr_ifindex = if_nametoindex("eth0");

	// 设置权限
	setsockopt(confd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &group, sizeof(group));

	while (1) {
		len = recvfrom(confd, buf, sizeof(buf), 0, NULL, 0);
		write(STDOUT_FILENO, buf, len);
	}
	close(confd);

	return 0;
}
```

### domain 本地套
IPC四种通信方式
1. pipe fifo	实现简单
2. mmap			进程间非血缘关系
3. signal		开销小
4. domain		稳定性好

```c
// server.c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <string.h>
#include <ctype.h>
#include <strings.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <stddef.h>

#include "wrap.h"

#define SERV_ADDR "serv.socket"

int main() {
	int lfd, cfd, len, size, i;
	struct sockaddr_un servaddr, cliaddr;
	char buf[BUFSIZ];
	
	lfd = Socket(AF_UNIX, SOCK_STREAM, 0);
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sun_family = AF_UNIX;
	strcpy(servaddr.sun_path, SERV_ADDR);
	
	/*
		offsetof(type, member)
		((int) &( (type*)0 )->member )
	*/
	len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);
	
	// 确保Bind之前不存在文件, Bind创建文件
	unlink(SERV_ADDR);
	// 参数3不是sizeof(servaddr)
	Bind(lfd, (struct sockaddr *)&servaddr, len);
	
	Listen(lfd, 20);

	printf("Accept ...\n");
	while (1) {
		len = sizeof(cliaddr);
		cfd = Accept(lfd, (struct sockaddr *)&cliaddr, (socklen_t *)&len);
		
		// 获取客户端socket文件名的长度
		len -= offsetof(struct sockaddr_un, sun_path);
		cliaddr.sun_path[len] = '\0';

		printf("client bind filename %s\n", cliaddr.sun_path);

		while ((size = read(cfd, buf, sizeof(buf))) > 0) {
			for (i = 0; i < size; ++i) {
				buf[i] = toupper(buf[i]);
			}
			write(cfd, buf, size);
		}
		close(cfd);
	}
	return 0;
}
```

```c
//client.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <ctype.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <stddef.h>
#include "wrap.h"

#define SERV_ADDR "serv.socket"
#define CLIE_ADDR "clie.socket"

int main () {
	int cfd, len;
	struct sockaddr_un servaddr, cliaddr;
	char buf[4096];

	cfd = Socket(AF_UNIX, SOCK_STREAM, 0);

	bzero(&cliaddr, sizeof(cliaddr));
	cliaddr.sun_family = AF_UNIX;
	strcpy(cliaddr.sun_path, CLIE_ADDR);

	// 计算地址结构的有效长度
	len = offsetof(struct sockaddr_un, sun_path) + strlen(cliaddr.sun_path);

	unlink(CLIE_ADDR);
	// 客户端也要bind, 不能依赖自动绑定
	Bind(cfd, (struct sockaddr *)&cliaddr, len);

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sun_family = AF_UNIX;
	strcpy(servaddr.sun_path, SERV_ADDR);

	// 计算服务端地址结构的长度
	len = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);

	Connect(cfd, (struct sockaddr *)&servaddr, len);

	while(fgets(buf, sizeof(buf), stdin) != NULL) {
		write(cfd, buf, strlen(buf));
		len = read(cfd, buf, sizeof(buf));
		write(STDOUT_FILENO, buf, len);
	}
	close(cfd);

	return 0;
}
```

## Shell

### 变量

```bash
# 命令起别名
alias ll='ls -al'
alias grep='grep --color=auto'
alias ls='ls --color=auto'

# 定义变量(默认在本地变量中), 添加到环境变量中
sanzo=666 # 定义
echo $sanzo # 打印
export sanzo # 添加到环境变量
env | grep sanzo
env | grep $sanzo
```

* 匹配多个任意字符
? 匹配一个任意字符
[若干字符] 匹配方括号中一个字符的一次出现

```bash
# 算术运算 10 + 20
var=10
echo $(($var+10))
echo $((var+10))
echo $[$var+10]
echo $[var+10]

echo &[2#10+8#12] # 2进制的10 + 8进制的12
```

- 转义字符

```bash
touch \$\ abc	# 创建$ abc文件
rm \$\ abc		# 删除$ abc文件

touch ./-abc  	# 创建-abc文件
touch -- -abc
rm ./-abc 	  	# 删除-abc文件
rm -- -abc

```

### 条件测试
test, []

```bash
# 满足返回0, 不满足返回1

[ -d dir ] 					# dir是目录为真
[ -f file ] 				# file是普通文件为真
[ -z STRING ]				# string长度是零为真
[ -n STRING ]				# string长度非零为真
[ STRING1 = STRING2 ]  		# 相同为真
[ STRING1 != STRING2 ] 		# 不同为真
[ ARG1 op ARG2 ]			# arg1, arg2为整数或取值为整数的变量, op有 -eq(等于), -ne(不等), -lt(小于), -le(小于等于), -gt(大于), -ge(大于等于)
test $var -le 100 			# 同上测试


echo $? # 输出上一次运行结果

VAR=
[ -n $VAR ] 	# 0
[ -n "$VAR" ]	# 1

-o	# 逻辑或
-a	# 逻辑与

[ -d dir -a $VAR = 10 ]	# dir是否为目录 而且 VAR等于10
变量取值最好放到""中
[ -d dir -a "$VAR" = 10 ]	# dir是否为目录 而且 VAR等于10
```

### 分支

- 判断文件类型
  ```bash
#! /bin/bash
  ```

if [ -d test ]; then
	echo "It is a dir"
elif [ -f test ]; then
	echo "It is a file"
else
	printf "Unknow\n"
fi

if :; then
	echo ": always true";
fi
  ```

- 读取用户输入

  ```bash
#! /bin/bash

echo "Is it morning? Please answer yes or no."

read YES_OR_NO

if [ "$YES_OR_NO" = "yes" ]; then
	echo "Good morning!"
elif [ "$YES_OR_NO" = no ]; then
	echo "Good afternoon!"
else
	echo "Sorry, $YES_OR_NO not recogized. Enter yes or no."
fi
  ```

- case语句
   ```bash
#! /bin/bash
   ```

echo "Is it morning? Please anser yes or no."

read YES_OR_NO

case "$YES_OR_NO" in
yes|Y|Yes|YES)
	echo "Good Morning!"
	;;
[nN]*)
	echo "Good Afternoon!"
	;;
*)
	echo "Sorry, $YES_OR_NO not recognized. Enter yes or no."
	return 1
	;;
esac

return 0
  ```

### 循环语句

- for/do/done

​```bash
#! /bin/bash

ls

for FILE in $(ls); do
	
	printf "$FILE "
	
	if [ -d "$FILE" ]; then
		echo "It is a dir"
	elif [ -f "$FILE" ]; then
		echo "It is a file"
	else
		echo "Other"
	fi
done
  ```

- while/do/done

```bash
#! /bin/bash

count=3

echo "Enter password"

read TRY

while [ "$TRY" != "secret" -a $count -gt 0 ]; do
	count=$[count-1]
	echo "Sorry, try again"
	read TRY
done
```

### 位置参数和特殊变量
$0、$1		# argv[0], argv[1]...
$#			# argc - 1
$@			# 参数列表, 可用在for循环的in后面
$*			# 参数列表, 同上
$?			# 上一条命令的exit status
$$			# 当前进程号

```bash
#! /bin/bash
shift # 参数列表左移

echo $0
echo $1
echo $2

echo $*
echo $@

echo $# 
```

### 输入输出

```bash
echo -e "hello\n" 	# 解析转义字符
echo -n "hello\n" 	# b不解析转义字符
```

```bash
ls -l | tee out		# tee保存到文件中一份

cmd > file 2>&1		# 输出重定向给file, 标准出错定向到标准输出

cmd < file1 > file2	# 从file中读取, 输出到file2中
cat < file1 > file2
wc -l < a.c > b

cmd < &fd			# 把文件描述符fd作为标准输入
cmd > &fd			# 把文件描述符fd作为标准输出
cmd < &- 			# 关闭标准输出
```

### 函数

```bash
#! /bin/bash

is_dir() 
{
	DIR_NAME=$1
	if [ ! -d $DIR_NAME ]; then
		return 1
	else
		return 0
	fi
}

for DIR in "$@"; do
	is_dir "$DIR"
	echo "$?"

	if is_dir "$DIR"; then :
	else 
		echo "$DIR doesn't exist. Creating it now..."
		mkdir $DIR > /dev/null 2>&1
		if [ $? -ne 0 ]; then
			echo "Cannot create dir $DIR"
			return 1
		fi
	fi
done
```
