

## errno

头文件

```cpp
#include <errno.h>
```

errno定义在头文件`/usr/include/errno.h`中，它是一个全局变量，任何标准C库函数都可以进行修改。

![](img/errno_setby_library.jpg)

errno是错误宏定义，在函数运行出错的时候，由内核设置错误信息。

第1-34个错误定义在`/usr/include/asm-generic/errno-base.h`。

第35-133个错误定义在`/usr/include/asm-generic/errno.h`。

![](img/erron.jpg)



## open

头文件

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

返回值

```cpp
-1	打开失败，同时设置errno
>0	文件描述符    
```

```bash
# 创建文件
int fd = open("filename", O_RDWR | O_CREAT, 0777);

# 判断文件是否存在
int fd = open("filename", O_RDWR | O_CREAT | O_EXCL, 0777);
errno == EEXIST

# 文件截断为0
int fd = open("filename", O_RDWR | O_TRUNC);

# 关闭文件
int ret = close(fd);
```

创建文件的实际权限为给定权限&本地掩码(取反)。

```
# 查看掩码
umask
```



## close

头文件

```cpp
#include <unistd.h>

int close(int fd);
```

返回值

```cpp
-1	关闭失败，同时设置errno
0	关闭正常
```



## exit

头文件

```cpp
#include <stdlib.h>

void exit(int status);
```



## perror

输出错误信息，参数表示首先需要输出的字符串。

```cpp
#include <stdio.h>

void perror(const char *s);
```



```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    
	// 打开文件
	int fd = open("hello", O_RDWR);
    
	// 判断是否成功
	if (fd == -1) {
        perror("open");
        exit(1);
    }


    // 创建新的文件
	int newfd = open("myhello", O_RDWR | O_CREAT, 0666);
    
	printf("fd = %d\n", newfd); 
    
	// 关闭文件
	int ret = close(newfd);

	if (ret == -1) perror("close失败");
}
```





## read

头文件

```cpp
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
```

返回值

```cpp
-1	读取失败并设置errno
0 	文件末尾
>0	读取的字节数
```



## write

头文件

```cpp
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t count);
```

返回值

```
-1	写入失败并设置errno
0	没有东西可写
>0	写入的字节数
```





```bash
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {

	int src = open("english.txt", O_RDWR);
	int dst = open("copy_enlish.txt", O_RDWR | O_CREAT, 0644);

	if (src == -1 | dst == -1) {
		perror("open");
	}

	char buf[1024];

	// 将文件从src读到dst中
	int rd = 0;
	while ((rd = read(src, buf, sizeof(buf))) > 0) {
		write(dst, buf, rd);
	}

	close(src);
	close(dst);

	return 0;
}

```





## lseek

头文件

```cpp
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence);
```

返回值

```cpp
-1 	定位失败并设置errno
>0 	距离开始的位置
```

| whence   |          |
| -------- | -------- |
| SEEK_SET | 文件开头 |
| SEEK_CUR | 当前位置 |
| SEEK_END | 文件末尾 |



```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() 
{
	int fd = open("english.txt", O_RDWR);
	if (fd == -1) perror("open");

	// 获取文件大小
	int len = lseek(fd, 0, SEEK_END);
	printf("english.txt length is %d\n", len);

	// 扩展文件大小
	len = lseek(fd, 10, SEEK_END);
	printf("english.txt length is %d\n", len);

	write(fd, "add", 3);

	close(fd);

	return 0;
}
```

文件指针的位置可以超过文件末尾，但是并不会改变文件的大小，需要进行写操作，才会改变文件的大小。



## stat

头文件

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf)
```

stat穿透函数，软连接文件链接的大小。(vim)

lstat不穿透函数，软连接的文件大小。(ls、rm)

![](img/stat.jpg)

返回值

```
-1 	失败，并设置errno
0	成功
```

```
 struct stat {
     dev_t     st_dev;         /* ID of device containing file */
     ino_t     st_ino;         /* Inode number */
     mode_t    st_mode;        /* File type and mode */
     nlink_t   st_nlink;       /* Number of hard links */
     uid_t     st_uid;         /* User ID of owner */
     gid_t     st_gid;         /* Group ID of owner */
     dev_t     st_rdev;        /* Device ID (if special file)
     */
     off_t     st_size;        /* Total size, in bytes */
     blksize_t st_blksize;     /* Block size for filesystem I/O */
     blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

    struct timespec st_atim;  /* Time of last access */
    struct timespec st_mtim;  /* Time of last modification */
    struct timespec st_ctim;  /* Time of last status change */

    #define st_atime st_atim.tv_sec      /* Backward compatibility */
    #define st_mtime st_mtim.tv_sec
    #define st_ctime st_ctim.tv_sec
};

```



```c
# 实现ls命令
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>

int main(int argc, char* argv[]) {
    if (argc < 2) { 
        printf("./a.out filename\n");
        exit(1);
    }
    struct stat st;
    int ret = stat(argv[1], &st);
    if (ret == -1) {
        perror("stat");
        exit(1);
    }
    // 存放文件类型和访问权限
    char perms[11] = {0};
    
    // 判断文件类型
    switch (st.st_mode & S_IFMT) {
        case S_IFLNK:
            perms[0] = 'l';
            break;
        case S_IFDIR:
            perms[0] = 'd';
            break;
        case S_IFREG:
            perms[0] = '-';
            break;
        case S_IFBLK:
            perms[0] = 'b';
            break;
        case S_IFCHR:
            perms[0] = 'c';
            break;
        case S_IFSOCK:
            perms[0] = 's';
            break;
        case S_IFIFO:
            perms[0] = 'p';
            break;
        default:
            perms[0] = '?';
            break;
    }

    // 判断文件访问权限
    // owner
    perms[1] = (st.st_mode & S_IRUSR) ? 'r' : '-';
    perms[2] = (st.st_mode & S_IWUSR) ? 'w' : '-';
    perms[3] = (st.st_mode & S_IXUSR) ? 'x' : '-';
    // group
    perms[4] = (st.st_mode & S_IRGRP) ? 'r' : '-';
    perms[5] = (st.st_mode & S_IWGRP) ? 'w' : '-';
    perms[6] = (st.st_mode & S_IXGRP) ? 'x' : '-';
    // others
    perms[7] = (st.st_mode & S_IROTH) ? 'r' : '-';
    perms[8] = (st.st_mode & S_IWOTH) ? 'w' : '-';
    perms[9] = (st.st_mode & S_IXOTH) ? 'x' : '-';
    // 硬链接数
    int linkNum = st.st_nlink;
    // 所有者
    char *fileOwner = getpwuid(st.st_uid)->pw_name;
    // 所属组
    char *fileGrp = getgrgid(st.st_gid)->gr_name;
    // 大小
    int fileSize = (int)st.st_size;
    // 修改时间
    char *time = ctime(&st.st_mtime);
    char mtime[512] = {0};
    strncpy(mtime, time, strlen(time) - 1);
    char buf[1024];
    sprintf(buf, "%s %d %s %s %d %s %s", perms, linkNum, fileOwner, fileGrp, fileSize, mtime, argv[1]);
    printf("%s\n", buf);
}
```



## access

```c
# 判断文件是否具有某种权限
int ret = access(argv[1], W_OK | R_OK | X_OK | F_OK);
F_OK 判断是否存在
ret = 0, 具有这些权限
ret = -1, 有些权限被禁止
```



## chmod

```c
# 修改文件权限
int main(int argc, char* argv[]) {
    if (argc < 3) {
        printf("./a.out filename 0644\n");
        exit(1);
    }

    int val = strtol(argv[2], NULL, 8); // 字符串转数字
    printf("%s %d\n", argv[2], val);
    int ret = chmod(argv[1], val);
    if (ret == -1) {
        perror("chmod");
        exit(1);
    }
}
```

## chown



```c
# 修改用户和组id
int main(int argc, char *argv[]) {
    if (argc < 4) {
        printf("./a.out filename uid gid\n");
        exit(1);
    }
    int uid = strtol(argv[2], NULL, 10);
    int gid = strtol(argv[3], NULL, 10);
    printf("uid = %d\n gid = %d\n", uid, gid);
    int ret = chown(argv[1], uid, gid);
    if (ret == -1) {
        perror("chown");
        exit(1);
    }
}
```



## truncate

```c
# 文件截断
int main(int argc ,char *argv[]) {
    if (argc < 3) {
        printf("./a.out filename size\n");
        exit(1);
    }
    int len = strtol(argv[2], NULL, 10);
    int ret = truncate(argv[1], len);
    if (ret == -1) {
        perror("truncate");
        exit(1);
    }
}
```



## readlink

```c
# 读取链接文件
int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("./a.out softlink\n");
        exit(1);
    }
    
    char buf[1024];
    int ret = readlink(argv[1], buf, sizeof(buf));
    if (ret == -1) {
        perror("readlink");
        exit(1);
    }
    buf[ret] = 0;
    printf("buf = %s\n", buf);
}
```



## unlink

```c
# 删除文件
int main(int argc, char *argv[]) {
    int fd = open("tmpfile", O_CREAT | O_RDWR, 0644);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // 删除临时文件
    int ret = unlink("tmpfile");
    
    // 写文件
    write(fd, "hello\n", 6);
    lseek(fd, 0, SEEK_SET);
    char buf[1024] = {0};
    // 读文件
    int len = read(fd, buf, sizeof(buf));
    // 输出到屏幕
    write(1, buf, len);

    close(fd);
    return 0;
}
```

## rename

```c
int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("./rename oldname newname\n");
        exit(1);
    }
    int ret = rename(argv[1], argv[2]);
    if (ret == -1) {
        perror("rename");
        exit(1);
    }
}
```



## chdir, getcwd

```c
int main(int argc, char *argv[]) {
	if (argc < 2) {
		printf("./chdir path\n");
		exit(1);
	}
	int ret = chdir(argv[1]);
	if (ret == -1) {
		perror("chdir");
		exit(1);
	}
	int fd = open("chdir.txt", O_CREAT | O_RDWR, 0777);
	if (fd == -1) {
		perror("open");
		exit(1);
	}
	close(fd);
	char buf[256];
	getcwd(buf, sizeof(buf));
	printf("current dir: %s\n", buf);
	return 0;
}
```

## opendir, readdir, closedir

```c
# 递归读取文件数目
int getFileNum(char *root) {
    // open dir
    DIR *dir = NULL;
    dir = opendir(root);
    if (dir == NULL) {
        perror("opendir");
        exit(1);
    }
    // 遍历当前目录
    int cnt = 0;
    char buf[1024] = {0};
    struct dirent *ptr = NULL;
    while((ptr = readdir(dir)) != NULL) {
        if(strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0)
            continue;
        if (ptr->d_type == DT_DIR) {
            sprintf(buf, "%s/%s", root, ptr->d_name);
            cnt += getFileNum(buf);
        }else if (ptr->d_type == DT_REG) {
            cnt++;
        }
    }
    // 关闭目录
    closedir(dir);
    return cnt;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("./fileNum dir\n");
        exit(1);
    }
    int cnt = 0;
    cnt = getFileNum(argv[1]);
    printf("%s %d\n", argv[1], cnt);
    return 0;
}
```



## dup, dup2

```c
# dup
int main() {
    int fd = open("a.txt", O_RDWR);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    printf("file fd = %d\n", fd);
    // 返回最小的文件描述符
    int ret = dup(fd);
    if (ret == -1) {
        perror("dup");
        exit(1);
    }
    printf("dup fd = %d\n", ret);
    char *buf = "hello world\n";
    char *buf1 = "hi world\n";
    // fd, ret指向同一个文件, 位置同步
    write(fd, buf, strlen(buf));
    write(ret, buf1, strlen(buf1));
    close(fd);
    return 0;
}

# dup2
int main() {
    int fd = open("a.txt", O_RDWR);
    if (fd == -1) {
        perror("a.txt open");
        exit(1);
    }
    int fd1 = open("b.txt", O_RDWR);
    if (fd1 == -1) {
        perror("b.txt open");
        exit(1);
    }
    printf("a.txt fd = %d\n", fd);
    printf("b.txt fd = %d\n", fd1);
    // 把fd复制到fd1           
    int ret = dup2(fd, fd1);
    if (ret == -1) {
        perror("dup2");
        exit(1);
    }
    printf("current fd1 = %d\n", fd1);
    char *buf = "dup2222222222222222222222222\n";
    write(fd, buf, strlen(buf));
    write(fd1, "hello world\n", 12);
    close(fd);
    close(fd1);

    return 0;
}
```



## fcntl

```c
int main() {
    int fd;
    int flag;
    char *buf = "桃花坞里桃花庵, 桃花庵下桃花仙";
    char *buf1 = "桃花仙人种桃树, 又摘桃花买酒钱";
    // open file
    fd = open("test.txt", O_WRONLY);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    
    if (write(fd, buf, strlen(buf)) == -1) {
        perror("write");
        exit(1);
    }
    
    flag = fcntl(fd, F_GETFL, 0);
    if (flag == -1) {
        perror("fcntl");
        exit(1);
    }
    // 添加文件状态: 追加
    flag |= O_APPEND;
    if (fcntl(fd, F_SETFL, flag) == -1) {
        perror("fcntl -- append write");
        exit(1);
    }

    if (write(fd, buf1, strlen(buf1)) == -1) {
        perror("write again");
        exit(1); 
    }
    close(fd);
    return 0;
}
```

