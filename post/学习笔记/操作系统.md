# 操作系统

## 进程和线程的区别

- 根本区别

  进程是资源分配的最小单位，线程是程序执行的最小单位。

  计算机在执行程序时，为程序创建相应的进程，进行资源分配时，是以进程为单位进行相应的分配。每个进程都有相应的线程，执行程序时，实际上是执行相应的线程。

- 地址空间

  进程有自己独立的地址空间，每启动一个进程，系统为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段；线程没有独立的地址空间，同一进程中的线程共享本进程的地址空间。

- 资源共享

  进程之间的资源是独立的，同一进程中的线程共享本进程的资源。

- 执行过程

  每个独立的进程有一个程序运行的入口，顺序执行序列和程序入口，但是线程不能独立执行，必须存在应用程序中，由程序控制执行。

  进程相互不会影响，线程挂掉可能导致整个进程挂掉。

- 系统开销

  进程的开销大，线程的开销小。



## fork函数

fork()系统调用会通过复制一个现有进程来创建一个全新的进程。进程存放在一个任务队列的双向链表中。链表当中的每一项都是task_struct称为进程描述符的结构，PCB进程控制块。

内核通过PID来标识每一个进程，默认最大值为32768（short的最大值）。

fork()创建子进程之后，父子进程同时从fork()后的代码开始运行。父子进程的执行顺序不确定，取决于内核使用的调度算法。

进程调用fork，内核会做4件事：

- 分配新的内存块和内核数据结构给子进程
- 将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程
- 添加子进程到系统进程列表
- fork返回，开始调度器调度

### 为什么fork调用返回两个值？

fork复制了父进程的堆栈，所以两个进程都停留在fork函数中等待返回。

父进程返回子进程的pid，这是因为进程可以有多个子进程，但是没有函数去获取子进程的pid。

子进程返回0，这是因为子进程可以通过getppid获取父进程的进程id，这个进程id不可能为0，返回0表示正常返回。

fork()之后的代码父子共享，父子都要主从这段代码，虽然子进程获得父进程的数据空间、堆栈的副本，但是子进程不共享这些存储空间。现在很多实现不是对父进程的数据段、堆栈的完全复制，采用写时拷贝技术，父子进程共享，内核设置访问权限为只读，如果父子进程中任一试图修改这些区域，内核为对应内存创建副本。



### 父子进程共享文件的问题

```c
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

int num = 0;
int main() {
	printf("hello world!\n");
	
	pid_t pid = fork();
	if (pid < 0) exit(1);

	if (pid == 0) { // 子进程
		printf("son pid = %d, num = %d\n", getpid(), ++num);

	}else { // 父进程
		sleep(1);
		printf("parent pid = %d, num = %d\n", getpid(), num);
	
	}

	return 0;
}
```

```c
pi@raspberrypi:~ $ ./a.out 
hello world!
son pid = 4868, num = 1
parent pid = 4867, num = 0
```

```c
// 将标准输出重定向到文件中
pi@raspberrypi:~ $ ./a.out > tmp
pi@raspberrypi:~ $ cat tmp
hello world!
son pid = 4870, num = 1
hello world!
parent pid = 4869, num = 0
```

使用标准IO库带有缓冲区，printf是行缓冲，如果执行了重定向操作，将标准输出到文件中，行缓冲就会变成全缓冲。fork()之前printf的数据会保存到缓冲区中，fork之后父进程的数据空间复制到子进程中，缓冲区的数据就被复制过去，在进程结束后都会打印输出。

**父子进程共享文件描述符关联的内核文件表项 struct file结构体**，父进程重定向，同时子进程也会重定向，父进程等待子进程结束时，子进程更新了共享文件的偏移量，所以父进程追加到子进程所写数据的后面。

### fork与vfork

vfork的实现是父子进程完全共享资源，修改内容main()函数退出都不会开辟空间。子进程没有使用exit()退出，程序就会出现段错误，原因是main函数被子进程释放，父进程访问不到。

- fork父子进程交替执行，vfork保证子进程先运行，父进程阻塞（或子进程调用exec或exit）
- fork实现写时拷贝，vfork直接让父子进程共享公共资源，避免开辟空间拷贝。
- vfork必须使用exit或excl退出



## 进程通信

### 无名管道

无名管道，多用于父子进程的通信。

- 半双工通信(数据只能在一个方向上流动)，有固定的读端和写端。
- 只能用于具有亲缘关系的进程之间的通信（父子进程、兄弟进程）。
- 可以看作特殊的文件使用read、write读写，但不是普通文件不属于文件系统，只存在内存中。

```c
#include <unistd.h>
int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```

pipe创建2个文件描述符fd[0]为读端，fd[1]为写端。

fork()之后，对应关闭不使用的文件描述符。

如果写端计数不为零，读端读取完数据之后会阻塞等待，否则read返回0结束。



### FIFO

用于不同进程间的通信，也可以用作客户端和服务器的通信。

FIFO通信方式类似通过文件来传输数据，FIFO类型文件同时具有管道的特性，在数据读出时，FIFO管道中同时清除数据，而且是“先进先出”

```c
#include <sys/stat.h>
// 返回值：成功返回0，出错返回-1
int mkfifo(const char *pathname, mode_t mode);
```

### 消息队列

- 消息队列是面向记录的，消息队列有特定格式和优先级。
- 消息队列独立于进程，进程终止消息队列的内容不会删除。
- 消息队列可以进行随机查询，可以按照消息的类型读取。

```c
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int flag);
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

在以下两种情况下，`msgget`将创建一个新的消息队列：

- 如果没有与键值key相对应的消息队列，并且flag中包含了`IPC_CREAT`标志位。
- key参数为`IPC_PRIVATE`。

函数`msgrcv`在读取消息队列时，type参数有下面几种情况：

- `type == 0`，返回队列中的第一个消息；
- `type > 0`，返回队列中消息类型为 type 的第一个消息；
- `type < 0`，返回队列中消息类型值小于或等于 type 绝对值的消息，如果有多个，则取类型值最小的消息。

可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把 type 看做优先级的权值。（其他的参数解释，请自行Google之）



### 信号量

信号量是一个计数器，用于实现进程间的互斥与同步，不是用户存储进程间通信数据。

- 用于进程间同步，进程间传递数据要集合共享内存。
- 信号量基于系统的PV操作，对信号量的操作是原子操作。
- 每次对信号量的PV操作不限于+1 -1
- 支持信号量组

```c
#include <sys/sem.h>
// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
int semget(key_t key, int num_sems, int sem_flags);
// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
int semop(int semid, struct sembuf semoparray[], size_t numops);  
// 控制信号量的相关信息
int semctl(int semid, int sem_num, int cmd, ...);
```



### 共享内存

指两个或多个进程共享一个给定的存储区

- 最快的一种IPC，进程对内存直接存取。
- 存在多个进程同时操作，需要进行同步。
- 信号量+共享内存通常结合在一起，信号量用来同步对共享内存的访问。

```c
#include <sys/shm.h>
// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1
int shmget(key_t key, size_t size, int flag);
// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1
void *shmat(int shm_id, const void *addr, int flag);
// 断开与共享内存的连接：成功返回0，失败返回-1
int shmdt(void *addr); 
// 控制共享内存的相关信息：成功返回0，失败返回-1
int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
```

### 5种通讯方式总结

1.管道：速度慢，容量有限，只有父子进程能通讯   

2.FIFO：任何进程间都能通讯，但速度慢   

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   

4.信号量：不能传递复杂消息，只能用来同步   

5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存



## IO模型

应用层利用TCP缓冲区来收发数据，TCP发送的消息是间断的。

### 阻塞IO

当应用请求读取数据时，内核还没有准备好，应用程序就处于等待数据的状态，等到内核将数据准备好，交给应用才结束。

### 非阻塞IO

应用请求读取数据时，内核没有准备好，立即返回（EWOULDBLOCK）。后面需要不断调用recvfrom，直到读取到需要的数据为止。

### 同步

在IO模型中，需要请求方从发送请求到收到数据，到最后完成，需要自己参与，这样叫做同步IO。

### 异步

应用程序发送指令之后不再参与，只需要等待最终完成结果通知，这种属于异步。

### IO复用

多个应用程序请求读数据，如果每一个线程都去调用recvfrom，会造成资源的浪费。IO复用就是通过select、poll、epoll来监控多个fd，而不是为每个线程创建一个监控线程，减少线程资源的浪费。



### select、poll、epoll

**select**将需要的监控的fd存储到fd_set中，通过调用select从用户态拷贝到内核态，内核对数组遍历，检查是否有可读写事件，如果没有读写事件，就删除对应的fd，返回fd_set数组，内核态向用户态拷贝。复杂度$O(n)$

fd_set是集合类型的数据结构，32为操作系统最大为1024，64为操作系统为2048，限制了select最多同时监控的连接数量。

**poll**通过链表来保存文件fd信息，没有最大连接数量限制，也是将用户传入的数组拷贝到内核态，复杂度$O(n)$

**epoll**在内核创建一个事件监听表，epoll_ctl来添加需要监听的读写事件，避免用户态到内核态的拷贝，对每个fd创建回调函数，事件激活后调用回调函数，加到活跃队列中，通过epoll_wait返回，复杂度$O(1)$

select、poll、epoll本质都是同步IO，当发生可读写事件，自己负责进行读写，这个读写过程是阻塞的。

epoll是linux特有的，select是操作系统都有的。

epoll有LT和ET两种触发模式，LT水平触发是默认模式，ET是边沿触发。水平触发，在没有处理的情况下，下次poll的时候会再次报告这个fd；边沿触发之后提示一次，直到下次再有数据之前不会再提示，所以每次read要把buffer读完。如果系统中有大量不需要读写的就绪fd，调用epoll_wait通知程序读写，会影响性能。边沿触发效率高，系统不会充斥大量不关心的fd。

epoll优点：

- 没有最大连接限制
- 效率提高，只有活跃的fd才会通过回调函数，通知程序。
- 利用mmap内存映射来完成文件和内核空间的消息传递，减少复制的开销。



总结：

- select，poll实现需要自己不断轮询所有fd集合，直到fd就绪，期间可能要睡眠和唤醒多次交替。而epoll需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

- select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝，这也能节省不少的开销。 

## 进程的3中状态

- 就绪状态

  进程分配到除cpu以外的其他资源，只要获取cpu就能运行。

- 执行状态

  当进程获取cpu，程序在cpu上执行。

- 阻塞状态

  正在执行的进程，等待某个事件的到来，而进入阻塞状态。IO请求、等待信号等。

进程状态的转化：

- 执行->就绪：时间片用完
- 就绪->执行：被调度
- 执行->阻塞：IO请求
- 阻塞->就绪：IO完成

## 产生死锁的条件

- 互斥：资源在同一时间，只能被一个任务使用。
- 请求和占有：拥有资源的进程可以请求另一个资源。
- 不可抢占：已经分配的资源，不同强制的被抢占，只能等待释放资源。
- 环路等待：有两个以上的进程，等待下一个进程所占有的资源。

## read、fread的区别

fread返回一个FILE的结构体指针，read返回读取的字节数。

fread带缓冲区是read的衍生，fread底层调用read。

fread自带缓冲区，减少调用次数。



## 缓存算法

- LRU（Least recently used）最近最少使用，如果数据最近被访问过，那么将来被访问的几率也更高。

  - 新数据插入到链表头部。
  - 每当缓存命中，将数据移动到链表头部。
  - 链表满，将链表尾部数据丢弃。

  可以使用哈希表来记录数据是否存在链表中。

- LFU（Least frequently used）最近不经常使用，如果一个数据在最近一段时间内使用的次数最少，那么在将来一段时间内被使用的可能性也小。

  主要看在一个时间段中页面使用的频率。

- FIFO（Fist in first out）先进先出，如果一个数据最先进入缓冲中，则应该最早淘汰掉。