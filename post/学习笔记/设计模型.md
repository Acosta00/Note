## 单例模型

对于系统中的某些类来说，只有一个实例很重要，比如一个打印机可以有多个打印任务，但是只有一个正在工作的任务，一个系统只能有一个窗口管理器或文件系统。

单例模型保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式的优点:

- 在内存中只有一个对象,节省内存空间

- 避免频繁的创建销毁对象,可以提高性能

- 避免对共享资源的多重占用

- 可以全局访问

```cpp
class Single{
private:
    Single();
    Single(const Single &);
    Single& operator= (const Single &);

public:
    static Single* getInstance() {
        static Single *m_Instance;
        if (m_Instance == NULL) {
            m_Instance = new Single();
        }
        return m_Instance;
    }
};
```



## 生产者消费模型

```c
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdio.h>
#include <queue>
using namespace std;

queue<int> que;
pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int num = 1;
void *consumer(void *p) {
    while (true) {
        pthread_mutex_lock(&lock);
        while (que.empty()) {
            pthread_cond_wait(&has_product, &lock);
        }
        int t = que.front();
        que.pop();
        pthread_mutex_unlock(&lock);
        printf("consume: %d\n", t);

    }
}

void *producer(void *p) {
    while (true) {
        printf("produce: %d\n", num);
        pthread_mutex_lock(&lock);
        que.push(num++);
        pthread_mutex_unlock(&lock);
        pthread_cond_signal(&has_product);
    }
}

int main() {

    pthread_t pid, cid;
    pthread_create(&pid, NULL, producer, NULL);
    pthread_create(&cid, NULL, consumer, NULL);

    pthread_join(pid, NULL);
    pthread_join(cid, NULL);

    return 0;
}
```

