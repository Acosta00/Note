## 单例模型

对于系统中的某些类来说，只有一个实例很重要，比如一个打印机可以有多个打印任务，但是只有一个正在工作的任务，一个系统只能有一个窗口管理器或文件系统。

单例模型保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式的优点:

- 在内存中只有一个对象,节省内存空间

- 避免频繁的创建销毁对象,可以提高性能

- 避免对共享资源的多重占用

- 可以全局访问

```cpp
/*
	存在线程安全、内存泄漏问题
*/
#include <iostream>
using namespace std;

class Singleton{
public:
    Singleton(const Singleton &) = delete;
    Singleton& operator = (const Singleton &) = delete;
    ~Singleton(){
        cout << "destructor" << endl;
    }

    static Singleton* getInstance() {
        if (instance == NULL) instance = new Singleton;
        return instance;
    }

    void show() {
        cout << &instance << endl;
    }

private:
    Singleton() {
        cout << "constructor" << endl;
    }
    static Singleton *instance;
};

Singleton* Singleton::instance = NULL;

int main() {
    Singleton* instance1 = Singleton::getInstance();
    Singleton* instance2 = Singleton::getInstance();

    instance1->show();
    instance2->show();

    return 0;
}
/*
    constructor
    0x407020
    0x407020
    请按任意键继续. . .
*/
```



```c
/*
	线程安全，无内存泄漏
	限制指针的使用（其他用户也要使用智能指针）、锁增加开销
*/

#include <memory>
#include <iostream>
#include <mutex>
using namespace std;

class Singleton{
public:
    typedef shared_ptr<Singleton> Ptr;
    Singleton(const Singleton &) = delete;
    Singleton& operator = (const Singleton &) = delete;
    ~Singleton(){
        cout << "destructor" << endl;
    }

    static Ptr getInstance() {
        // lock_guard<mutex> lk(mutex_);
        if (instance == NULL) instance = shared_ptr<Singleton> (new Singleton);
        return instance;
    }

    void show() {
        cout << &instance << endl;
    }

private:
    Singleton() {
        cout << "constructor" << endl;
    }
    static Ptr instance;
    // static mutex mutex_;
};

Singleton::Ptr Singleton::instance = NULL;

int main() {
    Singleton::Ptr instance1 = Singleton::getInstance();
    Singleton::Ptr instance2 = Singleton::getInstance();

    instance1->show();
    instance2->show();

    return 0;
}

/*
    constructor
    0x409020
    0x409020
    destructor
    请按任意键继续. . .
*/
```



```c
/*
	使用Magic static的特性：如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。
*/
#include <iostream>
using namespace std;

class Singleton{
public:
    Singleton(const Singleton &) = delete;
    Singleton& operator = (const Singleton &) = delete;
    ~Singleton(){
        cout << "destructor" << endl;
    }

    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

private:
    Singleton() {
        cout << "constructor" << endl;
    }
};

int main() {
    Singleton& instance1 = Singleton::getInstance();
    Singleton& instance2 = Singleton::getInstance();

    cout << &instance1 << endl;
    cout << &instance2 << endl;

    return 0;
}
```



## 生产者消费模型

```c
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdio.h>
#include <queue>
using namespace std;

queue<int> que;
pthread_cond_t has_product = PTHREAD_COND_INITIALIZER;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
int num = 1;
void *consumer(void *p) {
    while (true) {
        pthread_mutex_lock(&lock);
        while (que.empty()) {
            pthread_cond_wait(&has_product, &lock);
        }
        int t = que.front();
        que.pop();
        pthread_mutex_unlock(&lock);
        printf("consume: %d\n", t);

    }
}

void *producer(void *p) {
    while (true) {
        printf("produce: %d\n", num);
        pthread_mutex_lock(&lock);
        que.push(num++);
        pthread_mutex_unlock(&lock);
        pthread_cond_signal(&has_product);
    }
}

int main() {

    pthread_t pid, cid;
    pthread_create(&pid, NULL, producer, NULL);
    pthread_create(&cid, NULL, consumer, NULL);

    pthread_join(pid, NULL);
    pthread_join(cid, NULL);

    return 0;
}
```

